<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown 常用语法</title>
      <link href="/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-10.png" alt="upload successful"></p><p>Markdown 的语法全由一些符号所组成，易读易写。本文主要分享我平时经常使用到的 Markdown 语法。</p><span id="more"></span><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="单引用"><a href="#单引用" class="headerlink" title="单引用"></a>单引用</h3><p>使用符号 &gt; 标记区块引用，如：<br><br><br>&gt;我的博客：Yuanqian’s Blog，不止于技术分享。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog，不止于技术分享。</p></blockquote><h3 id="引用内的引用"><a href="#引用内的引用" class="headerlink" title="引用内的引用"></a>引用内的引用</h3><p>&gt; 标记里再使用 &gt;&gt; 标记，如：<br>&gt; 我的博客：Yuanqian’s Blog<br>&gt;&gt; 不止于技术分享，每天进步一点点，欢迎大家访问。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog</p><blockquote><p>不止于技术分享，每天进步一点点，欢迎大家访问。</p></blockquote></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>1、用底线的形式，= （第一阶标题）和 - （第二阶标题），数量不限，如：</p><p>效果是截图，左边是语法，右边是效果，下同。<br><img src="/images/pasted-7.png" alt="upload successful"></p><p>2、行首插入 1 到 6 个 #，对应到标题 1 到 6 阶，如：<br><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[Yuanqian’s Blog](<a href="https://zhangyuanqian.top/">https://zhangyuanqian.top/</a>)<br>效果如下：<br><br><a href="https://zhangyuanqian.top/">Yuanqian’s Blog</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Java 代表代码语言，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintCanvas</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        canvas.drawCircle(<span class="number">500</span>, <span class="number">550</span>, <span class="number">500</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>用两个星号或下划线包含内容，直接展示效果如下：<br><br><br>** 我的博客：Yuanqian’s Blog **</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。<br></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用*、+、—作为列表标记，如：</p><p>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br></p><p>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br></p><p>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br></p><p>三种写法都是如下效果:<br></p><ul><li>我的博客：Yuanqian’s Blog<br></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>只要数字接着一个英文句点，如：<br></p><p>1.bird<br><br>2.tiger<br><br>3.monkey<br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Markdown 常用语法介绍完毕，欢迎补充。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人民日报金句摘抄</title>
      <link href="/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/"/>
      <url>/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-76.png" alt="upload successful"></p><p>1.峥嵘过去已经彪炳史册，璀璨当下正在不断延伸，光明未来需要踏实开拓。 – 《人民日报》<br>2.最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。 – 《人民日报》</p><span id="more"></span><p>3.岁月因青春慨然以赴而更加静好，世间因少年挺身向前而更加瑰丽。 – 《人民日报》<br>4.与其朋友圈字斟句酌，不如现实中好好生活。 – 《人民日报》<br>5.真正的优秀不是别人逼出来的，而是自己和自己死磕。 – 《人民日报》<br>6.时代的考题已经列出，我们的答卷正在写就。 – 《人民日报》<br>7.人生不就是这样，经历过一次次考验才能成长；人生不就是这样，哪怕雨雪霏霾也要去追寻阳光。 – 《人民日报》<br>8.忆往昔，百年征程砥砺“同心”；看今朝，千秋伟业催人奋进。 – 《人民日报》<br>9.真理的波涛，喷涌而出就奔流不息；理想的火焰，一经点燃就不会熄灭。 – 《人民日报》<br>10.青春的烦恼，只有成长能解决；发展的瓶颈，只有成长才能突破。 – 《人民日报》<br>11.如果你想做一件事，马上就开始，别怕错。一辈子那么长，我们有的是时间来纠正。更何况，只要你开始，就会有收获。 – 《人民日报》</p><p>12.回望历史问初心，千秋伟业谁扛鼎？壮志豪情应犹在，逐梦不止方年轻。 – 陈凌 《人民日报》</p><p>13.距离并不是问题，相向而行才是关键 – 《人民日报》</p><p>14.所有人都在和过去好好告别之后，开始了新的生活，我们带着爱和希望踏上了人生又一段征程。此时回首，对过去满是感激。正是因为那些黯淡混浊的过去，才成就了此刻这个闪闪发光的自己。 – 《人民日报》</p><p>15.坚持一次早起，也许你能多写一篇晨间日记，多看20页书，多记几十个单词。短期看收效不大，但长期如此，往往决定了人生的差距。据说早起的人都有好运气，不妨从今天开始，把时间掌握在自己手里。 – 《人民日报》</p><p>16.生活是活给自己看的，你有多大成色，世界才会给你多大脸色。 – 《人民日报》</p><p>17.真相不是一块橡皮泥，可以随意揉捏；事实不是一张空白纸，可以自由裁剪。 – 《人民日报》</p><p>18.人生这条路很长，未来如星辰大海般璀璨，不必踟躇于过去的半亩方塘。那些所谓的遗憾，可能是一种成长；那些曾受过的伤，终会化作照亮前路的光。 – 《人民日报》</p><p>19.不以爱小而不为。很多时候,爱无关多么轰轰烈烈的表达,却恰恰来自于日常而琐碎的小事中,是发自内心的一举手一投足。赠人玫瑰,手有余香。 – 《人民日报》</p><p>20.时代有时代的大潮流、大节奏，我们也要有自己的小浪潮、小节奏，跟着时代奔跑，别掉了自有节拍。 – 《人民日报》</p>]]></content>
      
      
      <categories>
          
          <category> 考编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode12 占用空间过大的解决方法</title>
      <link href="/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-74.png" alt="upload successful"><br>Xcode12 硬盘占用空间 28G ，装完之后，让本不富裕的硬盘空间雪上加霜。<br>是啥占用了这么多空间？激发了我的好奇心。</p><span id="more"></span><p>三个占用空间最大的文件分别是:</p><p>第一名：iOS.simruntime  9.76 GB<br>第二名：tvOS.simruntime 5.39 GB<br>第三名：watchOS.simruntime 6.83 GB<br>iOS.simruntime日常使用删不得，tvOS.simruntime， watchOS.simruntime ，大部分开发者接触不到，可直接删除</p><p>文件路径：</p><p>Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/watchOS.simruntime</p><p>Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/tvOS.simruntime<br>enjoy~</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吹爆这个最近在用的 IDEA 神器！</title>
      <link href="/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/"/>
      <url>/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-59.png" alt="upload successful"></p><p>在做源码分析的时候，我们常常会有这样一种需求，一堆源码看完后，我想画个时序图把思路捋一下，像下面这样：</p><span id="more"></span><p><img src="/images/pasted-60.png" alt="upload successful"><br>画图的工具有很多，相信大部分小伙伴也都会画。<br>然而，画图太费时间了！！！而且这个图跟我们的代码关联性很大，就是照着代码画的。<br>那么问题就来了，能不能照着代码生成呢？要是能够照着代码生成，岂不是要爽很多。<br>今天松哥就给大家介绍一个我最近在用的 IDEA 插件 SequenceDiagram。</p><p>我不是那种收集狂，虽然我的笔记本并不卡，但是对于 IDEA 中安装插件我还是非常慎重的，很少装。不过这个 SequenceDiagram 确实不错，帮了我大忙，因此这里就给大家安利下。</p><ol><li>安装<br>先来时说说安装，IDEA 插件市场直接搜索并安装，这个是基本技能，我就不多说了：</li></ol><p><img src="/images/pasted-61.png" alt="upload successful"><br>装好之后记得重启一下 IDEA。<br>2. 功能<br>再来说说这个插件都有哪些功能？</p><p>生成简单的时序图。<br>通过单击时序图上的文本来导航代码。<br>可以从时序图中删除某一个类。<br>可以将时序图导出为图像。<br>可以将时序图导出为 PlantUML 文件。</p><p>另外还有三个实验性的功能：</p><p>智能界面<br>Lambda 表达式<br>Kotlin 支持</p><ol start="3"><li>用法<br>安装好 SequenceDiagram 之后，我们可以从如下几个地方启用它：</li></ol><p>在导航工具栏中，出现了如下图标（IDEA 左下角）：</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>工具菜单中 Tools -&gt; Sequence Diagram</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>在编辑器右键菜单中 Sequence Diagram …</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>在 IntentionAction 提示中 Generate sequence diagram（光标放在方法名上，按 alt+enter 或者 option+enter）：</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>通过这些地方我们可以生成时序图，最终生成的时序图如下：</p><p><img src="/images/pasted-66.png" alt="upload successful"><br>由图中可以清楚的看到方法的调用以及返回过程。<br>这张图中有几个细节，我们分别来看下。<br>先看左边一列按钮。<br>第一个三角是重新生成按钮（不好使，似乎有 BUG）。<br>第二个扳手是设置一些生成的细节，例如方法调用的深度，是否忽略 get/set，是否忽略私有方法/构造方法 等，如下图：</p><p><img src="/images/pasted-67.png" alt="upload successful"><br>下面的都是保存按钮了，可以保存为不同格式，小伙伴们可以自行尝试。<br>再看右边的图。<br>鼠标双击类名/方法名，会跳转到对应的类/方法上。<br>鼠标在类名/方法名上右键单击，可以从图中移除一个类/方法。</p><p><img src="/images/pasted-68.png" alt="upload successful"><br>差不多就这些用法吧，比较简单却很管用的一个插件，感兴趣的小伙伴可以试试哦～</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官问我JVM内存结构，我真的是</title>
      <link href="/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/"/>
      <url>/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-8.png" alt="upload successful"><br>面试官：今天来聊聊JVM的内存结构吧？<br>候选者：嗯，好的<br>候选者：前几次面试的时候也提到了：class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」<br>候选者：而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」<br>候选者：简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈<br>候选者：要值得注意的是：这是JVM「规范」的分区概念，到具体的实现落地，不同的厂商实现可能是有所区别的。<br> <span id="more"></span><br><img src="/images/pasted-0.png" alt="upload successful"><br>面试官：嗯，顺便讲下你这图上每个区域的内容吧。<br>候选者：好的，那我就先从「程序计数器」开始讲起吧。<br>候选者：Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」<br>候选者：所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）<br>面试官：好的，理解了。<br>候选者：那接下来我就说下「虚拟机栈」吧<br>候选者：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址</p><p><img src="/images/pasted-1.png" alt="upload successful"><br>候选者：了解了「虚拟机栈」的组成后，也不难猜出它的作用了：它保存方法了局部变量、部分变量的计算并参与了方法的调用和返回。<br>面试官：ok，了解了<br>候选者：下面就说下「本地方法栈」吧<br>候选者：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。<br>面试官：嗯…<br>候选者：嗯，说完了「本地方法栈」、「虚拟机栈」和「程序计数器」，哦，下面还有「方法区」和「堆」<br>候选者：那我先说「方法区」吧<br>候选者：前面提到了运行时数据区这个「分区」是JVM的「规范」，具体的落地实现，不同的虚拟机厂商可能是不一样的<br>候选者：所以「方法区」也只是 JVM 中规范的一部分而已。<br>候选者：在HotSpot虚拟机，就会常常提到「永久代」这个词。HotSpot虚拟机在「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商的虚拟机其实是没有「永久代」的概念的。</p><p><img src="/images/pasted-2.png" alt="upload successful"><br>候选者：我们下面的内容就都用HotSpot虚拟机来说明好了。<br>候选者：在JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了<br>面试官：嗯…<br>候选者：方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<br>候选者：类信息又包括了类的版本、字段、方法、接口和父类等信息。<br>候选者：常量池又可以分「静态常量池」和「运行时常量池」<br>候选者：静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。<br>候选者：「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息。</p><p><img src="/images/pasted-3.png" alt="upload successful"><br>面试官：嗯…<br>候选者：又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的<br>候选者：但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）<br>面试官：嗯，这信息量有点多<br>面试官：我想问下，你说从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？<br>候选者：最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。<br>候选者：按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」，主要是叫法不同，意思到位就好）<br>候选者：而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</p><p><img src="/images/pasted-4.png" alt="upload successful"><br>面试官：嗯，我听懂了<br>面试官：最后来讲讲「堆」这块区域吧<br>候选者：嗯，「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它<br>候选者：「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成<br>候选者：不多BB，我也画图吧</p><p><img src="/images/pasted-6.png" alt="upload successful"><br>候选者：将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）<br>面试官：那垃圾回收这块等下次吧，这个延伸下去又很多东西了<br>面试官：你要不先讲讲JVM内存结构和Java内存模型有啥区别吧？<br>候选者：他们俩没有啥直接关联，其实两次面试过后，应该你就有感觉了<br>候选者：Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果<br>候选者：Java内存结构（又称为运行时数据区域），它描述着当我们的class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担着什么作用。<br>面试官：了解了<br>今日总结：JVM内存结构组成（JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的）</p><p><img src="/images/pasted-7.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
