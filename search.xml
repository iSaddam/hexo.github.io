<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试官问我：了解Redis哨兵机制吗？7张图详解！</title>
      <link href="/2022/03/24/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%EF%BC%9A%E4%BA%86%E8%A7%A3Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F7%E5%BC%A0%E5%9B%BE%E8%AF%A6%E8%A7%A3%EF%BC%81/"/>
      <url>/2022/03/24/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%EF%BC%9A%E4%BA%86%E8%A7%A3Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F7%E5%BC%A0%E5%9B%BE%E8%AF%A6%E8%A7%A3%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h4 id="先聊聊什么是哨兵机制"><a href="#先聊聊什么是哨兵机制" class="headerlink" title="先聊聊什么是哨兵机制?"></a>先聊聊什么是哨兵机制?</h4><p>Redis的哨兵(sentinel) 系统用于管理多个 Redis 服务器,该系统执行以下三个任务:<br></p><p><strong>监控(Monitoring)：</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。<br></p><p><strong>提醒(Notification)：</strong> 当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。<br></p><p><strong>自动故障迁移(Automatic failover)：</strong> 当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。<br></p><span id="more"></span><h5 id="为什么要有哨兵机制？"><a href="#为什么要有哨兵机制？" class="headerlink" title="为什么要有哨兵机制？"></a>为什么要有哨兵机制？</h5><p>哨兵机制的出现是为了解决主从复制的缺点的！再这谈谈redis的主从复制的缺点:<br></p><ul><li>主从复制，若主节点出现问题，则不能提供服务，需要人工修改配置将从变主</li><li>主从复制主节点的写能力单机，能力有限</li><li>单机节点的存储能力也有限</li></ul><h5 id="哨兵机制-sentinel-的高可用"><a href="#哨兵机制-sentinel-的高可用" class="headerlink" title="哨兵机制(sentinel)的高可用"></a>哨兵机制(sentinel)的高可用</h5><p><strong>原理：</strong> 当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。<br><img src="/images/pasted-70.png" alt="upload successful"></p><p>其实整个过程只需要一个哨兵节点来完成，首先使用Raft算法（选举算法）实现选举机制，选出一个哨兵节点来完成转移和通知</p><h5 id="哨兵的定时监控任务"><a href="#哨兵的定时监控任务" class="headerlink" title="哨兵的定时监控任务"></a>哨兵的定时监控任务</h5><p><strong>任务1：</strong> 每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到。<br><img src="/images/pasted-71.png" alt="upload successful"><br><strong>任务2：</strong> 每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的。<br><img src="/images/pasted-72.png" alt="upload successful"><br><strong>任务3：</strong> 每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据。<br><img src="/images/pasted-73.png" alt="upload successful"><br><strong>客观下线：</strong> 当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，当超过quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线。</p><h5 id="领导者哨兵选举流程"><a href="#领导者哨兵选举流程" class="headerlink" title="领导者哨兵选举流程"></a>领导者哨兵选举流程</h5><ul><li>每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</li><li>当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</li><li>如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………</li></ul><h5 id="故障转移机制"><a href="#故障转移机制" class="headerlink" title="故障转移机制"></a>故障转移机制</h5><p><strong>由Sentinel节点定期监控发现主节点是否出现了故障：</strong> sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了<br><img src="/images/pasted-77.png" alt="upload successful"><br><strong>当主节点出现故障</strong>， 此时3个Sentinel节点共同选举了Sentinel3节点为领导，负载处理主节点的故障转移<br><img src="/images/pasted-78.png" alt="upload successful"><br><strong>由Sentinel3领导者节点执行故障转移，过程和主从复制一样，但是自动执行</strong><br><img src="/images/pasted-79.png" alt="upload successful"></p><p><strong>流程：</strong></p><ol><li>将slave-1脱离原从节点，升级主节点，</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ol><p><strong>故障转移后的redis sentinel的拓扑结构图</strong></p><h5 id="哨兵机制－故障转移详细流程-确认主节点"><a href="#哨兵机制－故障转移详细流程-确认主节点" class="headerlink" title="哨兵机制－故障转移详细流程-确认主节点"></a>哨兵机制－故障转移详细流程-确认主节点</h5><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择salve-priority从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，此指复制最完整的从节点</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>redis哨兵的作用:</strong></p><ol><li>监控主数据库和从数据库是否正常运行。</li><li>主数据库出现故障时，可以自动将从数据库转换为主数据库，实现自动切换。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 究竟是单线程还是多线程呢？</title>
      <link href="/2022/03/01/Redis-%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F/"/>
      <url>/2022/03/01/Redis-%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-55.png" alt="upload successful"><br>Redis一直以来都是高性能分布式缓存中间件的代表，我们经常说Redis是单线程的，也有人说Redis在6.0版本采用了多线程，那么Redis到底是采用单线程呢？还是多线程？本文我们来一探究竟</p><span id="more"></span><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Redis到底是单线程还是多线程的？<br></p><p>首先，Redis是一个高性能的分布式缓存中间件。其复杂性不言而喻，对于Redis整体而言肯定不是只有一个线程。<br></p><p>我们常说的Redis 是单线程，主要是指 Redis 在网络 IO和键值对读写是采用一个线程来完成的，这也是 Redis 对外提供键值存储服务的核心流程。但对于 Redis 的其他功能来说，比如持久化、异步删除、集群数据同步等，其实都是由额外的线程执行的。<br></p><h4 id="为什么要融入多线程？"><a href="#为什么要融入多线程？" class="headerlink" title="为什么要融入多线程？"></a>为什么要融入多线程？</h4><p>单线程的优势：</p><ul><li>使用单线程可以避免频繁的上下文切换</li><li>Redis 中有各种类型的数据操作，甚至包括一些事务处理，如果采用多线程，还可能因为加锁导致软件复杂度提升，更有可能会因为加解锁，甚至出现死锁，造成的性能损耗，所以使用单线程反而性能会更好</li></ul><p>单线程的劣势：</p><ul><li>无法发挥多核CPU的优势</li><li>当删除大建，会导致服务阻塞</li><li>QPS达到瓶颈</li></ul><p>基于上诉劣势，Redis也进行了相关优化，在4.0版本和6.0版本分别引入了Lazy Free和多线程IO。</p><h4 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h4><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。<br></p><p>文件事件处理器的四个重要组成部分：<br></p><ul><li>多个套接字请求</li><li>IO多路复用器</li><li>文件事件派发器</li><li>事件处理器</li></ul><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型，如下图所示。<br></p><p><img src="/images/pasted-56.png" alt="upload successful"></p><h4 id="带你理解Redis处理流程"><a href="#带你理解Redis处理流程" class="headerlink" title="带你理解Redis处理流程"></a>带你理解Redis处理流程</h4><h5 id="Redis-4-0之前的事件处理流程"><a href="#Redis-4-0之前的事件处理流程" class="headerlink" title="Redis 4.0之前的事件处理流程"></a>Redis 4.0之前的事件处理流程</h5><p>我们先介绍一下Redis（ 4.0之前）的执行原理，我们通过IO多路复用器监听来自客户端的socket网络连接，然后由主线程进行IO请求的处理以及命令的处理，所有操作都是线性的，我们可以抽象的理解为下图。<br></p><p><img src="/images/pasted-57.png" alt="upload successful"></p><h5 id="Redis-4-0-之后加入Lazy-Free机制"><a href="#Redis-4-0-之后加入Lazy-Free机制" class="headerlink" title="Redis 4.0 之后加入Lazy Free机制"></a>Redis 4.0 之后加入Lazy Free机制</h5><p>Redis 4.0 之前在处理客户端命令和IO操作时都是以单线程形式运行，期间不会响应其他客户端请求，但若客户端向Redis发送一条耗时较长的命令，比如删除一个含有上百万对象的Set键，或者执行flushdb，flushall操作，Redis服务器需要回收大量的内存空间，这事就会导致Redis服务阻塞，对于负载较高的缓存系统来说将会是个灾难。为了解决这个问题，在Redis 4.0版本引入了Lazy Free，目的是将慢操作异步化，这也是在事件处理上向多线程迈进了一步，其过程我们可以理解为下图。</p><p><img src="/images/pasted-58.png" alt="upload successful"></p><h5 id="Redis-6-0-之后将网络IO异步化"><a href="#Redis-6-0-之后将网络IO异步化" class="headerlink" title="Redis 6.0 之后将网络IO异步化"></a>Redis 6.0 之后将网络IO异步化</h5><p>从以上的发展历程中，我们也能看出Redis 的瓶颈并不在CPU上，即使是单线程Redis也能做到很快的响应，除非是遇到个别极其耗时的命令，这一块我们的Redis也在4.0版本做出了优化，但是我们是不是能更进一步优化Redis呢？从上图中我们可以看出主线程不光处理大量的命令，还需要处理大量的网络IO，Redis6.0就是基于此，将IO操作交由其他线程处理，抽象的理解如下图所示。</p><p><img src="/images/pasted-69.png" alt="upload successful"></p><p>Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：io-threads-do-reads yes <br></p><p>开启多线程后，还需要设置线程数，否则是不生效的。<br></p><p>线程数一定要小于机器核数。线程数并不是越大越好，官方认为超过了 8 个基本就没什么意义了。<br></p><p>设置线程数，修改redis.conf配置文件： io-threads <br></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何应对数据库缓存双写一致性问题</title>
      <link href="/2022/02/24/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/24/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-47.png" alt="upload successful"></p><span id="more"></span><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><hr><p>日常开发中，我们接口响应缓慢，往往是因为数据库读写产生的，这时为了优化这些接口，往往我们会将数据库的数据写入缓存中，让接口直接从缓存中获取数据，这样能极大的提高接口的访问速度。但是随之而来的问题就是，在我们更新数据库的数据时，就需要去更新缓存中的数据，或者是删除缓存中的数据，让其再次访问时通过读数据库，再将读到的数据刷入缓存中。但是如果在这期间出现并发，就很容易导致数据库缓存中数据不一致，这也是本篇文章的主题如何应对数据库缓存双写一致性问题。<br><br>这里我们说的一致性是指最终一致性，并不是强一致性。<br></p><h5 id="推荐方案-Cache-Aside-Pattern"><a href="#推荐方案-Cache-Aside-Pattern" class="headerlink" title="推荐方案 Cache Aside Pattern"></a>推荐方案 Cache Aside Pattern</h5><hr><p>命中：程序从缓存读取数据，读到数据即命中<br></p><p>失效：程序从缓存读取数据，未读到数据，此时缓存失效，需要先去数据库读取，再刷入缓存<br></p><p>更新：先更新数据库，再删除缓存<br></p><h5 id="更新方案"><a href="#更新方案" class="headerlink" title="更新方案"></a>更新方案</h5><hr><ul><li><p>更新缓存</p></li><li><p>先更新缓存，再更新数据库</p></li><li><p>先更新数据库，再更新缓存</p></li><li><p>删除缓存</p></li><li><p>先删除缓存，再更新数据库</p></li><li><p>先更新数据库，再删除缓存（常用）</p></li></ul><h5 id="更新方案选择原因"><a href="#更新方案选择原因" class="headerlink" title="更新方案选择原因"></a>更新方案选择原因</h5><hr><h6 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h6><p>如下图，当A线程更新完缓存的数据A，这时A线程出现延迟，B线程将A线程缓存的更新覆盖，并且将数据库中的数据A也更新，A线程恢复去更新数据库，这时又将B线程对数据库的修改覆盖，这样就会出现严重的双写不一致，导致后续每次读取到的缓存中的数据都是有问题的，并且数据库的数据对我们来说更为重要，我们一般持久化都是依赖数据库的，如果先更新缓存的话，后续程序宕机，数据库中的数据就得不到更新，我们一般是不会依赖缓存做持久化保存的，所以这种方案是一定不能选择的。</p><p><img src="/images/pasted-48.png" alt="upload successful"></p><h6 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h6><p>如下图，当A线程更新完数据库的数据A，这时A线程出现延迟，B线程将A线程数据库的更新覆盖，并且将缓存中的数据A也更新，A线程恢复去更新缓存，这时又将B线程对缓存的修改覆盖，这样就会出现严重的双写不一致，导致后续每次取到缓存中的数据都是有问题的。</p><p><img src="/images/pasted-49.png" alt="upload successful"></p><h6 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h6><p>如下图，当A线程删除缓存数据A，这时A线程出现延迟，B线程将读取A，发现缓存无数据，将数据库A的旧值查出来，并且将其更新到缓存中，当A线程恢复时，又将A的新值写入数据库，这样也会出现严重的双写不一致，导致后续每次取到缓存中的数据都是有问题的。</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><p>所以，先删除缓存的方案也不建议选择。</p><h6 id="先更新数据库，再删除缓存（常用）"><a href="#先更新数据库，再删除缓存（常用）" class="headerlink" title="先更新数据库，再删除缓存（常用）"></a>先更新数据库，再删除缓存（常用）</h6><p>先更新数据库再删除缓存这种方案是我们所选择的，当然这种也有几率出现缓存不一致的现象，当缓存失效时，就会出现和先删除缓存，在更新数据库一样的问题。如下图:</p><p><img src="/images/pasted-51.png" alt="upload successful"></p><p>但是一般情况下，是不会出现上述情况，出现上述情况的机率是特别低的。出现上述情况也可以采取延迟双删，先删除一次，让线程休眠一会，再删除一次，就会将不小心写入的错误数据清掉。</p><p>所以说这种方案只会出现下一种情况，如果想要避免这种情况只能通过加锁来解决，避免读到脏数据</p><p><img src="/images/pasted-52.png" alt="upload successful"></p><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><hr><p>基于上述方案我们还可以做哪些优化</p><ul><li>读数据加锁（分布式锁）防止高并发打垮数据库</li><li>延迟双删，防止缓存失效时（读写分离架构下，读从库延迟问题），存入旧数据，第二次删除可以异步执行等待删除</li><li>如果需要做重试机制可以依赖于消息队列的可靠消费</li><li>可以通过订阅Binlog日志来优化删除逻辑</li></ul><p>禁忌：过度设计，一般简单的延迟双删就可以实现需求，无需增加系统复杂度</p><p><img src="/images/pasted-54.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多张图带你彻底搞懂DNS域名解析过程</title>
      <link href="/2022/02/22/%E5%A4%9A%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/02/22/%E5%A4%9A%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-38.png" alt="upload successful"></p><span id="more"></span><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><hr><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。</p><h4 id="域名系统DNS-的作用"><a href="#域名系统DNS-的作用" class="headerlink" title="域名系统DNS 的作用"></a>域名系统DNS 的作用</h4><hr><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br><br>因此，即使不使用域名也可以通过IP地址来寻址目的主机，但域名与IP地址相比，便于人们记忆。因此对于大多数网络应用，我们一般使用域名来访问目的主机，而不是直接使用IP地址来访问。<br><br>对于本例，简单来说，当我们在浏览器地址栏中输入某个Web服务器的域名时。用户主机首先用户主机会首先在自己的DNS高速缓存中查找该域名所应的IP地址。<br></p><p><img src="/images/pasted-39.png" alt="upload successful"><br>如果没有找到，则会向网络中的某台DNS服务器查询，DNS服务器中有域名和IP地映射关系的数据库。当DNS服务器收到DNS查询报文后，在其数据库中查询，之后将查询结果发送给用户主机。<br><br><img src="/images/pasted-40.png" alt="upload successful"></p><p>现在，用户主机中的浏览器可以通过Web服务器的IP地址对其进行访问了。<br></p><p><img src="/images/pasted-41.png" alt="upload successful"></p><h4 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h4><hr><h5 id="层级关系特点"><a href="#层级关系特点" class="headerlink" title="层级关系特点"></a>层级关系特点</h5><ul><li>因特网采用层次树状结构的域名结构</li><li>域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名。<ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ul></li><li>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理。</li></ul><h5 id="因特网的域名空间"><a href="#因特网的域名空间" class="headerlink" title="因特网的域名空间"></a>因特网的域名空间</h5><p><img src="/images/pasted-42.png" alt="upload successful"></p><p>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。<br></p><h5 id="域名服务器可以划分为以下四种不同的类型"><a href="#域名服务器可以划分为以下四种不同的类型" class="headerlink" title="域名服务器可以划分为以下四种不同的类型:"></a>域名服务器可以划分为以下四种不同的类型:</h5><ul><li>根域名服务器：根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。</li><li>顶级域名服务器：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</li><li>权限域名服务器：这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。</li><li>本地域名服务器：本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</li></ul><h4 id="DNS-域名解析过程"><a href="#DNS-域名解析过程" class="headerlink" title="DNS 域名解析过程"></a>DNS 域名解析过程</h4><hr><p>域名解析包含两种查询方式，分别是递归查询和迭代查询。</p><h5 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h5><p>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<br><br>我们以一个例子来了解DNS递归查询的工作原理，假设图中的主机 (IP地址为m.xyz.com) 想知道域名y.abc.com的IP地址。<br></p><ul><li>1、我们以一个例子来了解DNS递归查询的工作原理，假设图中的主机 (IP地址为m.xyz.com) 想知道域名y.abc.com的IP地址。</li><li>2、本地域名服务器收到递归查询的委托后，也采用递归查询的方式向某个根域名服务器查询。</li><li>3、根域名服务器收到递归查询的委托后，也采用递归查询的方式向某个顶级域名服务器查询。</li><li>4、顶级域名服务器收到递归查询的委托后，也采用递归查询的方式向某个权限域名服务器查询。</li></ul><p>过程如图所示：</p><p><img src="/images/pasted-43.png" alt="upload successful"></p><p>当查询到域名对应的IP地址后，查询结果会在之前受委托的各域名服务器之间传递，最终传回给用户主机。</p><p>过程如图所示：</p><p><img src="/images/pasted-44.png" alt="upload successful"></p><h5 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h5><p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<br></p><p>迭代查询过程如下：<br></p><ul><li>1、主机首先向其本地域名服务器进行递归查询。</li><li>2、本地域名服务器采用迭代查询，它先向某个根域名服务器查询。</li><li>3、根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器的IP地址。</li><li>4、本地域名服务器向顶级域名服务器进行迭代查询。</li><li>5、顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器的IP地址。</li><li>6、本地域名服务器向权限域名服务器进行迭代查询。</li><li>7、权限域名服务器告诉本地域名服务器所查询的域名的IP地址。</li><li>8、本地域名服务器最后把查询的结果告诉主机。</li></ul><p>过程如图所示：</p><p><img src="/images/pasted-45.png" alt="upload successful"></p><p>由于递归查询对于被查询的域名服务器负担太大，通常采用以下模式：从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><hr><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。<br></p><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项（例如，每个项目只存放两天)。<br></p><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。<br></p><p>如图所示：</p><p><img src="/images/pasted-46.png" alt="upload successful"></p><p>如果本地域名服务器不久前已经有用户查询过域名为y.abc.com的IP地址，则本地域名服务器的高速缓存中应该存有该域名对应的IP地址。因此，直接把高速缓存中存放的上次查询结果(即y.abc.com的IP地址)告诉用户。</p><h4 id="DNS相关面试问题"><a href="#DNS相关面试问题" class="headerlink" title="DNS相关面试问题"></a>DNS相关面试问题</h4><hr><h5 id="DNS为什么用UDP？"><a href="#DNS为什么用UDP？" class="headerlink" title="DNS为什么用UDP？"></a>DNS为什么用UDP？</h5><p>更正确的答案是 DNS 既使用 TCP 又使用 UDP。当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。<br></p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。<br></p><h5 id="递归查询和递归查询区别？"><a href="#递归查询和递归查询区别？" class="headerlink" title="递归查询和递归查询区别？"></a>递归查询和递归查询区别？</h5><p>递归查询: 如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<br></p><p>迭代查询： 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<br></p><h5 id="讲讲DNS解析过程？"><a href="#讲讲DNS解析过程？" class="headerlink" title="讲讲DNS解析过程？"></a>讲讲DNS解析过程？</h5><p>详细解析过程请看上文DNS域名解析过程，这里我们做一个总结：<br></p><p>浏览器缓存——》系统hosts文件——》本地DNS解析器缓存——》本地域名服务器（本地配置区域资源、本地域名服务器缓存)——》根域名服务器——》主域名服务器——》下一级域名域名服务器 客户端——》本地域名服务器（递归查询) 本地域名服务器—》DNS服务器的交互查询是迭代查询</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK15新特性体验</title>
      <link href="/2022/02/10/JDK15%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/02/10/JDK15%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-37.png" alt="upload successful"><br>JDK15发布共包含了14个新特性，其中不乏一些功能的二次预览。下面，就来看一下4个能影响到我们编码习惯的功能吧。<br></p><span id="more"></span><p>JDK15可以配合IDEA 2020.2版本运行，测试前需要在Project Structure中修改Project language level开启对新特性的支持等级。<br><br><img src="/images/pasted-30.png" alt="upload successful"></p><h4 id="一、Sealed-Classes"><a href="#一、Sealed-Classes" class="headerlink" title="一、Sealed Classes"></a>一、Sealed Classes</h4><hr><p>Sealed Classes表示一个封闭类，它能够防止其他类或接口扩展或实现它们。当一个类被sealed关键字修饰时，只能通过已知的子类型列表进行扩展，而不能通过其他任何扩展。</p><p>看一个简单的示例，允许2个子类对其进行扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> <span class="title">permits</span> <span class="title">AirCondition</span>, <span class="title">Television</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在permits 后的列表中的类可以正常继承父类，并扩展自己的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Television</span> <span class="keyword">extends</span> <span class="title">Machine</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Television</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name +<span class="string">&quot; is working&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Television can play movie&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当意图扩展一个不在permits 中的类时，编译时会告诉你无法继承：<br><img src="/images/pasted-31.png" alt="upload successful"></p><h4 id="二、Pattern-Matching-for-instanceof"><a href="#二、Pattern-Matching-for-instanceof" class="headerlink" title="二、Pattern Matching for instanceof"></a>二、Pattern Matching for instanceof</h4><hr><p>模式匹配功能在jdk14中就已经被预览过一次，本次为第二次预览。简单的说，该功能就是普通instanceof 的增强版。<br><br>该功能允许我们在instanceof 后面的类型后再添加一个变量名，避免了再创建一次局部变量，进行一次赋值过程。同时，还能够减少我们在进行强制类型转换时手动造成的错误。<br><br>在String后面添加一个变量名，并直接可被引用：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o=<span class="string">&quot;pattern test&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以在后面加其他的判断条件。首先构建一个简单的实体类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在instanceof 后面加上一个判断条件：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceTest3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   Object object</span>=<span class="keyword">new</span> Book(<span class="string">&quot;Hydra monster&quot;</span>,<span class="number">20.8</span>);</span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Book book </span><br><span class="line">         &amp;&amp; book.getName().equals(<span class="string">&quot;Hydra monster&quot;</span>))&#123;</span><br><span class="line">       System.out.println(book.getPrice());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、Text-Blocks"><a href="#三、Text-Blocks" class="headerlink" title="三、Text Blocks"></a>三、Text Blocks</h4><hr><p>文本块功能已经在之前几版jdk中被预览过，在jdk15中转为正式功能。它允许我们自定义一个多行的字符串，可以避免使用大多数转义符号。并且可以让程序员按照自己的意愿控制文本块的输出格式。<br><br>文本块功能通过3个连续的双引号开启，同样以3个连续双引号关闭：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    String html = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">            &lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;p&gt;text block, test&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;                </span></span><br><span class="line"><span class="string">            &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><br><img src="/images/pasted-32.png" alt="upload successful"><br>怎么样，是不是减少了平常代码时很多的 \r 和 \n ，以及字符串的拼接操作。<br><br>另外，通过添加 \ 符号还可以控制禁止换行：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   String sql = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">           select * from user_info \</span></span><br><span class="line"><span class="string">           where  \</span></span><br><span class="line"><span class="string">           user_name = &#x27;Hydra&#x27;\</span></span><br><span class="line"><span class="string">           &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">   System.out.println(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><br><img src="/images/pasted-33.png" alt="upload successful"></p><h4 id="四、Records"><a href="#四、Records" class="headerlink" title="四、Records"></a>四、Records</h4><hr><p>Records 是一种新的类的声明形式，是一种受限制的类。经常听到一些同学抱怨，说java中有太多繁冗的get、set方法，在这种条件下lombok应景而生，而在jdk15中出现的Record可以说也具有类似的功能，在一些特定的场景下可以取代lombok。<br><br>定义一个record 的类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Person</span><span class="params">(String name , String age)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化类并调用内置方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    Person person</span>=<span class="keyword">new</span> Person(<span class="string">&quot;Hydra&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    System.out.println(person.age());</span><br><span class="line">    System.out.println(person.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/pasted-34.png" alt="upload successful"><br>那么代码中为什么可以直接调用构造函数等没有实现的方法呢，看一下编译后的class文件就明白了：<br><img src="/images/pasted-35.png" alt="upload successful"><br>在编译后生成的类自动继承了Record父类，并且自动生成了构造方法、toString，hashCode，equals，以及成员变量获取值的方法。之前已经看到toString方法的输出方式和lombok相同，再来验证一下equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equalsTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    Person person</span>=<span class="keyword">new</span> Person(<span class="string">&quot;Hydra&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    Person person2=<span class="keyword">new</span> Person(<span class="string">&quot;Trunks&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    Person person3=<span class="keyword">new</span> Person(<span class="string">&quot;Hydra&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    System.out.println(person.equals(person2));</span><br><span class="line">    System.out.println(person.equals(person3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/images/pasted-36.png" alt="upload successful"><br>可以看到，内置的equals方法很贴心的按照对象的属性值进行比较，而不是比较对象的内存地址。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 的初级配置</title>
      <link href="/2022/02/09/nginx-%E7%9A%84%E5%88%9D%E7%BA%A7%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/02/09/nginx-%E7%9A%84%E5%88%9D%E7%BA%A7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要用于记录nginx.conf这一个文件如何修改的相关问题。<br><br>当nginx安装之后，默认的配置如下所示（数据来源为宝塔自动生成），本篇博客重点介绍的是配置虚拟机相关内容，即server 块配置项。server块的指令主要用于设置主机和端口，location块用于匹配网页路径，一个http块可以包含多个  server。</p><span id="more"></span><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.域名.com;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root /www/wwwroot/目录;</span><br><span class="line">    </span><br><span class="line">    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则</span><br><span class="line">    #error_page 404/404.html;</span><br><span class="line">    #SSL-END</span><br><span class="line">    </span><br><span class="line">    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span><br><span class="line">    #error_page 404 /404.html;</span><br><span class="line">    #error_page 502 /502.html;</span><br><span class="line">    #ERROR-PAGE-END</span><br><span class="line">    </span><br><span class="line">    #PHP-INFO-START  PHP引用配置，可以注释或修改</span><br><span class="line">    include enable-php-73.conf;</span><br><span class="line">    #PHP-INFO-END</span><br><span class="line">    </span><br><span class="line">    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效</span><br><span class="line">    include /www/server/panel/vhost/rewrite/域名伪静态文件.conf;</span><br><span class="line">    #REWRITE-END</span><br><span class="line">    </span><br><span class="line">    #禁止访问的文件或目录</span><br><span class="line">    location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)</span><br><span class="line">    &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #一键申请SSL证书验证目录相关设置</span><br><span class="line">    location ~ \.well-known&#123;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">    &#123;</span><br><span class="line">        expires      30d;</span><br><span class="line">        error_log /dev/null;</span><br><span class="line">        access_log /dev/null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ .*\.(js|css)?$</span><br><span class="line">    &#123;</span><br><span class="line">        expires      12h;</span><br><span class="line">        error_log /dev/null;</span><br><span class="line">        access_log /dev/null; </span><br><span class="line">    &#125;</span><br><span class="line">    access_log  /www/wwwlogs/域名.log;</span><br><span class="line">    error_log  /www/wwwlogs/域名.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面要学习的第一个内容，就是各个配置的含义。<br></p><h3 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h3><hr><h4 id="虚拟主机监听的端口号"><a href="#虚拟主机监听的端口号" class="headerlink" title="虚拟主机监听的端口号"></a>虚拟主机监听的端口号</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen 80;</span><br></pre></td></tr></table></figure><h4 id="绑定的域名"><a href="#绑定的域名" class="headerlink" title="绑定的域名"></a>绑定的域名</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name www.域名.com;</span><br></pre></td></tr></table></figure><p>多个域名用空格分隔。</p><h4 id="配置默认页"><a href="#配置默认页" class="headerlink" title="配置默认页"></a>配置默认页</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index index.php index.html index.htm default.php default.htm default.html;</span><br></pre></td></tr></table></figure><h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 匹配 URL</span><br><span class="line">location / &#123;</span><br><span class="line">    # 访问路径，可以是相对路径或者绝对路径</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较重要，尤其是  location 后面的规则，语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ &#123;</span><br><span class="line"># 编写代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> =：精确匹配；</li><li> <del>：区分大小写匹配（可用正则），与之对应的是  !</del>；</li><li> <del>*：不区分大小写的匹配（可用正则），与之对应的是  !</del>*；</li><li> ^~：以某个字符串开头；</li><li> /：通配符，任何请求都会匹配到；</li></ul><p>基于上述内容，再去观察上述默认配置，就能读懂了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 当访问 user.ini,htaccess 等文件时，直接返回 404</span><br><span class="line">location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md)</span><br><span class="line">&#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br><span class="line"># 匹配 .well-known </span><br><span class="line">location ~ \.well-known&#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 匹配以 gif,jpg,jpeg等后缀结尾的文件</span><br><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">&#123;</span><br><span class="line">    expires      30d;</span><br><span class="line">    error_log /dev/null;</span><br><span class="line">    access_log /dev/null;</span><br><span class="line">&#125;</span><br><span class="line"># 匹配以 js,css 结尾的文件</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">    expires      12h;</span><br><span class="line">    error_log /dev/null;</span><br><span class="line">    access_log /dev/null; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在匹配到的规则内容中，编写防盗链代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valid_referers none blocked 域名1.cn 域名1.cn;</span><br><span class="line"># 如果是</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line"># 防盗链</span><br><span class="line">rewrite ^/ http://$host/logo.png;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中  valid_referers 语法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valid_referers [none|blocked|server_names]</span><br></pre></td></tr></table></figure><ul><li> none：默认值，表示无 referer 值的情况；</li><li> blocked：表示 referer 值被防火墙进行伪装；</li><li> server_names：域名列表，可以使用通配符 * 号。</li></ul><p>如果匹配到规则，那么会将 $invalid_referer 变量设置为 1。<br></p><p>这里又延伸出 nginx 全局变量相关内容，这个还有有必要记忆一下的，基于它们可以实现很多逻辑。<br>假设请求的地址为  <a href="http://www.baidu.com:88/test1/test2/a.php?ttt=123">http://www.baidu.com:88/test1/test2/a.php?ttt=123</a><br></p><ul><li>$args：请求中的参数，与 $query_string 一致，即 ttt=123；</li><li>$content_length：请求头中的Content-Length 字段；</li><li>$content_type：请求头中的Content-Type字段；</li><li>$document_root：当前请求在root指令中指定的值；</li><li>$document_uri：与 $uri 一致，请求 URI，即 <a href="http://www.baidu.com:88/test1/test2/a.php%EF%BC%9B">http://www.baidu.com:88/test1/test2/a.php；</a></li><li>$host：请求中的主机头字段，即 <a href="http://www.baidu.com;/">www.baidu.com；</a></li><li>$http_user_agent：客户端浏览器的相关信息；</li><li>$http_cookie：客户端cookie信息；</li><li>$limit_rate：限制连接速率；</li><li>$request_body_file：客户端请求主体信息的临时文件名；</li><li>$request_method：请求方法；</li><li>$remote_addr：客户端的ip地址；</li><li>$remote_port：客户端的端口号；</li><li>$remote_user：客户端用户名称；</li><li>$request_filename：当前请求的文件路径；</li><li>$request_uri：包含请求参数的原始 URI，不包含主机名，即 /test1/test2/a.php</li><li>$status：请求状态码，成功是200；</li><li>$http_referer：页面来源；</li><li>$server_name：请求服务器名；</li><li>$server_port：请求=的服务器端口号；</li></ul><p>于此同时我们还可以在 nginx 请求中判断请求的是否是文件，目录等内容。</p><ul><li>-f 和 !-f 用来判断文件；</li><li>-d 和 !-d 用来判断目录；</li><li>-e 和 !-e 用来判断文件或目录；</li><li>-x 和 !-x 用来判断文件是否可执行。</li></ul><p>上述还有一个参数 rewrite 表示重写规则，它可以使用 nginx 提供的全局变量或我们设置的变量，结合正则表达式和标志位实现 url 重写与重定向。<br>rewrite 只能放在 server{} ， location{} ， if{} 中。<br>rewrite 只能对域名后边的除去传递的参数外的字符串起作用，例如 <a href="http://www.aaaa.com/a/b/c.php?id=1&amp;user=hihell">http://www.aaaa.com/a/b/c.php?id=1&amp;user=hihell</a> 只对 /a/b/c.php 重写。<br>rewrite 语法格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement [flag];</span><br></pre></td></tr></table></figure><p>上述语法中的 flag 有如下取值：</p><ul><li>last：表示完成 rewrite，一般写在 server{} 和 if{} 中；</li><li>break：停止执行当前虚拟主机的后续rewrite指令集；</li><li>redirect ：返回302临时重定向，地址栏会显示跳转后的地址；</li><li>permanent：返回301永久重定向，地址栏会显示跳转后的地址。</li></ul><p>其中还有一个需要特别注意就是 $1 ， $2 ，这些都是前面正则小括号里面的对应内容。<br></p><p>举例如下：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"># 匹配到 ^/news/([0-9]&#123;5&#125;)\.html$，转换为 /news_$1</span><br><span class="line">        rewrite &#x27;^/news/([0-9]&#123;5&#125;)\.html$&#x27; /news_$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述内容表示匹配到 /news/123456.html 的请求，重写为 /news_123456 。<br></p><h3 id="其它可用配置"><a href="#其它可用配置" class="headerlink" title="其它可用配置"></a>其它可用配置</h3><hr><h4 id="单连接请求上限数"><a href="#单连接请求上限数" class="headerlink" title="单连接请求上限数"></a>单连接请求上限数</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">keepalive_requests 120;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="允许的域名与禁止的域名"><a href="#允许的域名与禁止的域名" class="headerlink" title="允许的域名与禁止的域名"></a>允许的域名与禁止的域名</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">location [=|~|~*|^~] /uri/ &#123;</span><br><span class="line"> deny www.baidu.com;  # 拒绝的域名</span><br><span class="line">         allow 111.111.111.111; # 允许的 ip  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反向代理设置"><a href="#反向代理设置" class="headerlink" title="反向代理设置"></a>反向代理设置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;   </span><br><span class="line">    proxy_set_header Host $host:$server_port;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 proxy_pass 参数表示设置被代理服务器的 URL 和端口；<br>proxy_set_header 设置 header 参数，例如 Host ， X-Real-IP ， X-Forwarded-For<br><br>设置错误页<br>error_page 参与的语法规则为<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error_page 404 502 = @fetch;</span><br><span class="line">location @fetch &#123;</span><br><span class="line">access_log /logs/face.log log404;</span><br><span class="line">rewrite ^(.*)$ http://域名:端口/face.jpg redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 块中的其它配置</p><ul><li>ssl_certificate：</li><li>ssl_certificate_key：</li><li>ssl_session_timeout：</li><li>expires 2h：缓存2小时；</li><li>listen 443 ssl：在https访问的时候，需要证书验证；</li></ul><p>nginx 80重定向443 命令如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名1.com 域名2.com;</span><br><span class="line">    return 301 https://$http_host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name 域名1.com 域名2.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有 2 个参数需要说明 $http_host ， $request_uri ，其中 $request_uri 在前文已经进行了说明，表示除 host 以外的其它部分。 $http_host 参数存在几个类似值：<br></p><ul><li>$host：浏览器请求的 IP，无端口；</li><li>$http_host：浏览器请求的 IP/端口号，端口存在即显示；</li><li>$proxy_host：被代理服务的 IP/端口号，80端口不显示，其它显示。</li></ul><p>请求日志 error_log 参数用于设置日志存储位置。<br></p><p>访问控制 allow/deny 在每个块中都可以设置多个 allow ， deny ，分别表示允许或禁止某个 IP 或IP 段访问。<br></p><p>return命令 该命令语法格式为<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return code ;</span><br></pre></td></tr></table></figure><p>该命令用于结束规则的执行并返回状态码给客户端。<br></p><p>Set命令 该命令语法格式为<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $variable value ;  # 默认值：none</span><br></pre></td></tr></table></figure><p>该命令用于定义一个变量，并给变量赋值。变量的值可为文本，变量及二者联合。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资深开发竟然不清楚int(1)和int(10)的区别</title>
      <link href="/2022/02/08/%E8%B5%84%E6%B7%B1%E5%BC%80%E5%8F%91%E7%AB%9F%E7%84%B6%E4%B8%8D%E6%B8%85%E6%A5%9Aint-1-%E5%92%8Cint-10-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/08/%E8%B5%84%E6%B7%B1%E5%BC%80%E5%8F%91%E7%AB%9F%E7%84%B6%E4%B8%8D%E6%B8%85%E6%A5%9Aint-1-%E5%92%8Cint-10-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-28.png" alt="upload successful"></p><span id="more"></span><h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><hr><p>最近遇到个问题，有个表的要加个user_id字段，user_id字段可能很大，于是我提mysql工单<table><tr><td bgcolor="#FF4500">alter table xxx ADD user_id int(1)。</td></tr></table>领导看到我的sql工单，于是说：这int(1)怕是不够用吧，接下来是一通解释。<br><br>其实这不是我第一次遇到这样的问题了，其中不乏有工作5年以上的老司机。包括我经常在也看到同事也一直使用int(10)，感觉用了int(1)，字段的上限就被限制，真实情况肯定不是这样。<br></p><h3 id="数据说话"><a href="#数据说话" class="headerlink" title="数据说话"></a>数据说话</h3><hr><p>我们知道在mysql中 int占4个字节，那么对于无符号的int，最大值是2^32-1 = 4294967295，将近40亿，难道用了int(1)，就不能达到这个最大值吗？<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(1) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>id字段为无符号的int(1)，我来插入一个最大值看看。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO `user` (`id`) VALUES (4294967295);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到成功了，说明int后面的数字，不影响int本身支持的大小，int(1)、int(2)…int(10)没什么区别。<br></p><h3 id="零填充"><a href="#零填充" class="headerlink" title="零填充"></a>零填充</h3><hr><p>一般int后面的数字，配合zerofill一起使用才有效。先看个例子：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(4) unsigned zerofill NOT NULL AUTO_INCREMENT,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意int(4)后面加了个zerofill，我们先来插入4条数据。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO `user` (`id`) VALUES (1),(10),(100),(1000);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分别插入1、10、100、1000 4条数据，然后我们来查询下：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 0001 |</span><br><span class="line">| 0010 |</span><br><span class="line">| 0100 |</span><br><span class="line">| 1000 |</span><br><span class="line">+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过数据可以发现 int(4) + zerofill实现了不足4位补0的现象，单单int(4)是没有用的。 而且对于0001这种，底层存储的还是1，只是在展示的会补0。<br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>int后面的数字不能表示字段的长度，int(num)一般加上zerofill，才有效果。zerofill的作用一般可以用在一些编号相关的数字中，比如学生的编号 001 002 … 999这种，如果mysql没有零填充的功能，但是你又要格式化输出等长的数字编号时，那么你只能自己处理了。<br><br><img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用 Vsftpd 搭建 FTP 服务</title>
      <link href="/2022/01/27/Linux-%E4%BD%BF%E7%94%A8-Vsftpd-%E6%90%AD%E5%BB%BA-FTP-%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/01/27/Linux-%E4%BD%BF%E7%94%A8-Vsftpd-%E6%90%AD%E5%BB%BA-FTP-%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-25.png" alt="upload successful"><br>&nbsp;&nbsp;本文以 centos 的Linux服务器为例，使用 Vsftpd 搭建被动模式的 FTP 服务。</p><span id="more"></span><h2 id="FTP-的两种模式"><a href="#FTP-的两种模式" class="headerlink" title="FTP 的两种模式"></a>FTP 的两种模式</h2><hr><p>FTP 存在两种模式，PORT(主动)模式和PASV(被动)模式。</p><h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><p>FTP服务器“主动”去连接客户端的数据端口来传输数据。 即客户端从一个任意的非特权端口N（N&gt;1024）连接到FTP服务器的21端口。然后客户端开始监听N+1，并发送 PORT N+1 到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。</p><p><img src="/images/pasted-26.png" alt="upload successful"></p><h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p>FTP服务器“被动”等待客户端来连接自己的数据端口。 即当开启一个FTP连接时，客户端打开两个任意的非特权本地端口（N &gt;1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交 PORT 命令并允许服务器来回连它的数据端口，而是提交 PASV 命令。这样做的结果是服务器会开启一个任意的非特权端口（P &gt; 1024），并发送 PORT P 命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。(此模式下的FTP服务器不需要开启tcp 20端口)</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h3 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h3><p>（1）PORT（主动）模式只要开启服务器的21和20端口，而PASV（被动）模式需要开启服务器大于1024所有tcp端口和21端口。<br>（2）从网络安全的角度来看的话似乎 PORT 模式更安全，而 PASV 更不安全，那么为什么 RFC 要在 PORT 基础再制定一个 PASV 模式呢？其实 RFC 制定 PASV 模式的主要目的是为了数据传输安全角度出发的，因为 PORT 使用固定20端口进行传输数据，那么作为黑客很容使用sniffer等探嗅器抓取 ftp 数据，这样一来通过 PORT 模式传输数据很容易被黑客窃取，因此使用 PASV 方式来架设 ftp server 是最安全绝佳方案。</p><h2 id="安装-Vsftpd"><a href="#安装-Vsftpd" class="headerlink" title="安装 Vsftpd"></a>安装 Vsftpd</h2><ol><li>安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置-Vsftpd"><a href="#配置-Vsftpd" class="headerlink" title="配置 Vsftpd"></a>配置 Vsftpd</h2><ol><li>为 FTP 服务创建一个用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd ftpuser</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>设置该用户的密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd ftpuser</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>为 FTP 服务创建一个用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/ftp/ftpupload</span><br><span class="line">chown -R ftpuser:ftpuser /var/ftp/ftpupload</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>编辑配置文件 /etc/vsftpd/vsftpd.conf</li></ol><ul><li>修改 配置文件之前先备份 </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/vsftpd.conf /etc/vsftpd.conf.back</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改以下配置参数,监听 IPv4 或 IPv6 只能选择开启一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> \# 匿名用户的登录权限</span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line">\# 本地用户的登录权限</span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line">\# 将所有用户限制在主目录</span><br><span class="line">chroot_local_user=</span><br><span class="line"></span><br><span class="line">\# 启动限制用户的名单</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"></span><br><span class="line">\# 例外用户列表文件的路径</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">\# 开启监听 IPv4 sockets</span><br><span class="line">listen=YES</span><br><span class="line"></span><br><span class="line">\# 关闭监听 IPv6</span><br><span class="line">\#listen_ipv6=YES</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建并编辑配置中 chroot_list_file 指定的例外用户列表文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/vsftpd/chroot_list</span><br></pre></td></tr></table></figure><ul><li>重启 FTP 服务</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中为什么不建议v-if 和v-for一起使用？</title>
      <link href="/2022/01/27/vue%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEv-if-%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F/"/>
      <url>/2022/01/27/vue%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEv-if-%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-24.png" alt="upload successful"></p><span id="more"></span><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染<br></p><p>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名<br></p><p>在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化<br></p><p>两者在用法上<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo v-if=&quot;isShow&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &#123;&#123; item.label &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、优先级"><a href="#二、优先级" class="headerlink" title="二、优先级"></a>二、优先级</h2><p>v-if与v-for都是vue模板系统中的指令<br></p><p>在vue模板编译的时候，会将指令系统转化成可执行的render函数<br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写一个p标签，同时使用v-if与 v-for <br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in list&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建vue实例，存放isShow与items数据<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &quot;#app&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123; name: &quot;Tom&quot; &#125;,</span><br><span class="line">        &#123; name: &quot;Jack&quot; &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isShow() &#123;</span><br><span class="line">      return this.list &amp;&amp; this.list.length &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板指令的代码都会生成在render函数中，通过app.$options.render可以得到渲染函数<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with (this) &#123; return </span><br><span class="line">    _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, </span><br><span class="line">    _l((list), function (item) </span><br><span class="line">    &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\n&quot; + _s(item.name) + &quot;\n&quot;)]) : _e() &#125;), 0) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>_l是vue的列表渲染函数，函数内部都会进行一次if判断<br></p><p>初步得到结论：v-for优先级是比v-if高<br></p><p>再将v-for与v-if置于不同标签<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with(this)&#123;return </span><br><span class="line">    _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,</span><br><span class="line">    [(isShow)?[_v(&quot;\n&quot;),</span><br><span class="line">    _l((list),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.name))])&#125;)]:_e()],2)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染<br></p><p>我们再在查看下vue源码<br></p><p>源码位置：/vue-dev/src/compiler/codegen/index.js<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function genElement (el: ASTElement, state: CodegenState): string &#123;</span><br><span class="line">  if (el.parent) &#123;</span><br><span class="line">    el.pre = el.pre || el.parent.pre</span><br><span class="line">  &#125;</span><br><span class="line">  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    return genStatic(el, state)</span><br><span class="line">  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    return genOnce(el, state)</span><br><span class="line">  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    return genFor(el, state)</span><br><span class="line">  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    return genIf(el, state)</span><br><span class="line">  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">    return genChildren(el, state) || &#x27;void 0&#x27;</span><br><span class="line">  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;</span><br><span class="line">    return genSlot(el, state)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在进行if判断的时候，v-for是比v-if先进行判断<br></p><p>最终结论：v-for优先级比v-if高<br></p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ol><li>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li><li>如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;isShow&quot;&gt;</span><br><span class="line">    &lt;p v-for=&quot;item in list&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    items: function() &#123;</span><br><span class="line">      return this.list.filter(function (item) &#123;</span><br><span class="line">        return item.isShow</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地在 Spring Boot 中使用自定义注解，AOP 切面统一打印出入参日志</title>
      <link href="/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-Spring-Boot-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8CAOP-%E5%88%87%E9%9D%A2%E7%BB%9F%E4%B8%80%E6%89%93%E5%8D%B0%E5%87%BA%E5%85%A5%E5%8F%82%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-Spring-Boot-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8CAOP-%E5%88%87%E9%9D%A2%E7%BB%9F%E4%B8%80%E6%89%93%E5%8D%B0%E5%87%BA%E5%85%A5%E5%8F%82%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-11.png" alt="upload successful"></p><span id="more"></span><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><hr><p>一、先看看切面日志输出效果</p><p>二、添加 AOP Maven 依赖</p><p>三、自定义日志注解</p><p>四、配置 AOP 切面</p><p>五、怎么使用呢？</p><p>六、对于文件上传好使不？</p><p>七、只想在开发环境和测试环境中使用？</p><p>八、多切面如何指定优先级？</p><hr><h5 id="一、先看看切面日志输出效果"><a href="#一、先看看切面日志输出效果" class="headerlink" title="一、先看看切面日志输出效果"></a>一、先看看切面日志输出效果</h5><hr><p>在看看实现方法之前，我们先看下切面日志输出效果咋样：<br></p><p><img src="/images/pasted-12.png" alt="upload successful"><br>Spring boot 自定义注解，aop切面统一打印请求日志效果图<br><br>从上图中可以看到，每个对于每个请求，开始与结束一目了然，并且打印了以下参数：</p><ul><li>URL: 请求接口地址；</li><li>Description: 接口的中文说明信息；</li><li>HTTP Method: 请求的方法，是 POST, GET, 还是 DELETE 等；</li><li>Class Method: 被请求的方法路径 : 包名 + 方法名;</li><li>IP: 请求方的 IP 地址；</li><li>Request Args: 请求入参，以 JSON 格式输出；</li><li>Response Args: 响应出参，以 JSON 格式输出；</li><li>Time-Consuming: 请求耗时，以此估算每个接口的性能指数；</li></ul><h5 id="二、添加-AOP-Maven-依赖"><a href="#二、添加-AOP-Maven-依赖" class="headerlink" title="二、添加 AOP Maven 依赖"></a>二、添加 AOP Maven 依赖</h5><hr><p>在项目 pom.xml 文件中添加依赖：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- aop 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用于日志切面中，以 json 格式打印出入参 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="三、自定义日志注解"><a href="#三、自定义日志注解" class="headerlink" title="三、自定义日志注解"></a>三、自定义日志注解</h5><hr><p>让我们来自定义一个日志注解，如下所示：<br><img src="/images/pasted-13.png" alt="upload successful"></p><ol><li>什么时候使用该注解，我们定义为运行时；</li><li>注解用于什么地方，我们定义为作用于方法上；</li><li>注解是否将包含在 JavaDoc 中；</li><li>注解名为 WebLog;</li><li>定义一个属性，默认为空字符串；</li></ol><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.exception.springbootaopwebrequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 犬小哈 （微信号：小哈学Java）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span> www.exception.site</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 下午9:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@discription</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志描述信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，一个完整的自定义注解就定义完成了。</p><h5 id="四、配置-AOP-切面"><a href="#四、配置-AOP-切面" class="headerlink" title="四、配置 AOP 切面"></a>四、配置 AOP 切面</h5><hr><p>在配置 AOP 切面之前，我们需要了解下 aspectj 相关注解的作用：</p><ul><li>@Aspect：声明该类为一个注解类；</li><li>@Pointcut：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法；<br>切点定义好后，就是围绕这个切点做文章了：</li><li>@Before: 在切点之前，织入相关代码；</li><li>@After: 在切点之后，织入相关代码;</li><li>@AfterReturning: 在切点返回内容后，织入相关代码，一般用于对返回值做些加工处理的场景；</li><li>@AfterThrowing: 用来处理当织入的代码抛出异常后的逻辑处理;</li><li>@Around: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点；</li></ul><p><img src="/images/pasted-14.png" alt="upload successful"><br>&nbsp;&nbsp; 注解执行顺序<br></p><p>接下来，定义一个 WebLogAspect.java 切面类，声明一个切点：<br><img src="/images/pasted-15.png" alt="upload successful"><br>&nbsp;&nbsp; 定义一个切点<br></p><p>然后，定义 @Around 环绕，用于何时执行切点：<br><img src="/images/pasted-16.png" alt="upload successful"><br>&nbsp;&nbsp; 环绕<br></p><ol><li>记录一下调用接口的开始时间；</li><li>执行切点，执行切点后，会去依次调用 @Before -&gt; 接口逻辑代码 -&gt; @After -&gt; @AfterReturning；</li><li>打印出参；</li><li>打印接口处理耗时；</li><li>返回接口返参结果；</li></ol><p>再来看看 @Before 方法：</p><p><img src="/images/pasted-17.png" alt="upload successful"><br>&nbsp;&nbsp;@Before<br><br>看注释功能说明，因为注释说得还是比较清楚的！</p><p>最后，用 @After 来做个收尾：</p><p><img src="/images/pasted-18.png" alt="upload successful"><br>&nbsp;&nbsp;换行</p><p><img src="/images/pasted-19.png" alt="upload successful"><br>&nbsp;&nbsp;@After</p><p>我们在每个接口的最后，打印日志结束标志。最后再看下项目包结构：</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>&nbsp;&nbsp;项目包结构</p><p>到这里，切面相关的代码就完成了！</p><p>上完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.exception.springbootaopwebrequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 犬小哈 （微信号：小哈学Java）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span> www.exception.site</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 下午9:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@discription</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger         = LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line">    <span class="comment">/** 换行符 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.lineSeparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 以自定义 <span class="doctag">@WebLog</span> 注解为切点 */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(site.exception.springbootaopwebrequest.aspect.WebLog)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之前织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 开始打印请求日志</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 @WebLog 注解的描述信息</span></span><br><span class="line">        String methodDescription = getAspectLogDescription(joinPoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印请求相关参数</span></span><br><span class="line">        logger.info(<span class="string">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 url</span></span><br><span class="line">        logger.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">// 打印描述信息</span></span><br><span class="line">        logger.info(<span class="string">&quot;Description    : &#123;&#125;&quot;</span>, methodDescription);</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        logger.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        logger.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        logger.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>, <span class="keyword">new</span> Gson().toJson(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之后织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 接口结束后换行，方便分割查看</span></span><br><span class="line">        logger.info(<span class="string">&quot;=========================================== End ===========================================&quot;</span> + LINE_SEPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 打印出参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class="keyword">new</span> Gson().toJson(result));</span><br><span class="line">        <span class="comment">// 执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切面注解的描述</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 描述信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAspectLogDescription</span><span class="params">(JoinPoint joinPoint)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String targetName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] arguments = joinPoint.getArgs();</span><br><span class="line">        Class targetClass = Class.forName(targetName);</span><br><span class="line">        Method[] methods = targetClass.getMethods();</span><br><span class="line">        StringBuilder description = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                Class[] clazzs = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (clazzs.length == arguments.length) &#123;</span><br><span class="line">                    description.append(method.getAnnotation(WebLog.class).description());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> description.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="五、怎么使用呢？"><a href="#五、怎么使用呢？" class="headerlink" title="五、怎么使用呢？"></a>五、怎么使用呢？</h5><hr><p>因为我们的切点是自定义注解 @WebLog, 所以我们仅仅需要在 Controller 控制器的每个接口方法添加 @WebLog 注解即可，如果我们不想某个接口打印出入参日志，不加注解就可以了：</p><p><img src="/images/pasted-21.png" alt="upload successful"><br>&nbsp;&nbsp;用户登录接口</p><h5 id="六、对于文件上传好使不？"><a href="#六、对于文件上传好使不？" class="headerlink" title="六、对于文件上传好使不？"></a>六、对于文件上传好使不？</h5><hr><p>是好使的！不论是单文件上传，抑或是多文件上传，切面日志均运行良好，这里测试的东西，小哈就不贴出来了。有兴趣的小伙伴可以试试！</p><h5 id="七、只想在开发环境和测试环境中使用？"><a href="#七、只想在开发环境和测试环境中使用？" class="headerlink" title="七、只想在开发环境和测试环境中使用？"></a>七、只想在开发环境和测试环境中使用？</h5><hr><p>对于那些性能要求较高的应用，不想在生产环境中打印日志，只想在开发环境或者测试环境中使用，要怎么做呢？我们只需为切面添加 @Profile 就可以了，如下图所示：</p><p><img src="/images/pasted-22.png" alt="upload successful"><br>&nbsp;&nbsp;指定profile</p><p>这样就指定了只能作用于 dev 开发环境和 test 测试环境，生产环境 prod 是不生效的！</p><h5 id="八、多切面如何指定优先级？"><a href="#八、多切面如何指定优先级？" class="headerlink" title="八、多切面如何指定优先级？"></a>八、多切面如何指定优先级？</h5><hr><p>假设说我们的服务中不止定义了一个切面，比如说我们针对 Web 层的接口，不止要打印日志，还要校验 token 等。要如何指定切面的优先级呢？也就是如何指定切面的执行顺序？<br>我们可以通过 @Order(i)注解来指定优先级，注意：i 值越小，优先级则越高。<br>假设说我们定义上面这个日志切面的优先级为 @Order(10), 然后我们还有个校验 token 的切面 CheckTokenAspect.java，我们定义为了 @Order(11), 那么它们之间的执行顺序如下：</p><p><img src="/images/pasted-23.png" alt="upload successful"><br>&nbsp;&nbsp;多切点优先级</p><p>我们可以总结一下：</p><ul><li>在切点之前，@Order 从小到大被执行，也就是说越小的优先级越高；</li><li>在切点之后，@Order 从大到小被执行，也就是说越大的优先级越高；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 常用语法</title>
      <link href="/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-10.png" alt="upload successful"></p><p>Markdown 的语法全由一些符号所组成，易读易写。本文主要分享我平时经常使用到的 Markdown 语法。</p><span id="more"></span><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="单引用"><a href="#单引用" class="headerlink" title="单引用"></a>单引用</h3><p>使用符号 &gt; 标记区块引用，如：<br><br><br>&gt;我的博客：Yuanqian’s Blog，不止于技术分享。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog，不止于技术分享。</p></blockquote><h3 id="引用内的引用"><a href="#引用内的引用" class="headerlink" title="引用内的引用"></a>引用内的引用</h3><p>&gt; 标记里再使用 &gt;&gt; 标记，如：<br>&gt; 我的博客：Yuanqian’s Blog<br>&gt;&gt; 不止于技术分享，每天进步一点点，欢迎大家访问。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog</p><blockquote><p>不止于技术分享，每天进步一点点，欢迎大家访问。</p></blockquote></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>1、用底线的形式，= （第一阶标题）和 - （第二阶标题），数量不限，如：</p><p>效果是截图，左边是语法，右边是效果，下同。<br><img src="/images/pasted-7.png" alt="upload successful"></p><p>2、行首插入 1 到 6 个 #，对应到标题 1 到 6 阶，如：<br><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[Yuanqian’s Blog](<a href="https://zhangyuanqian.top/">https://zhangyuanqian.top/</a>)<br>效果如下：<br><br><a href="https://zhangyuanqian.top/">Yuanqian’s Blog</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Java 代表代码语言，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintCanvas</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        canvas.drawCircle(<span class="number">500</span>, <span class="number">550</span>, <span class="number">500</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>用两个星号或下划线包含内容，直接展示效果如下：<br><br><br>** 我的博客：Yuanqian’s Blog **</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。<br></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用*、+、—作为列表标记，如：</p><p>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br></p><p>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br></p><p>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br></p><p>三种写法都是如下效果:<br></p><ul><li>我的博客：Yuanqian’s Blog<br></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>只要数字接着一个英文句点，如：<br></p><p>1.bird<br><br>2.tiger<br><br>3.monkey<br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Markdown 常用语法介绍完毕，欢迎补充。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人民日报金句摘抄</title>
      <link href="/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/"/>
      <url>/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-76.png" alt="upload successful"></p><p>1.峥嵘过去已经彪炳史册，璀璨当下正在不断延伸，光明未来需要踏实开拓。 – 《人民日报》<br>2.最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。 – 《人民日报》</p><span id="more"></span><p>3.岁月因青春慨然以赴而更加静好，世间因少年挺身向前而更加瑰丽。 – 《人民日报》<br>4.与其朋友圈字斟句酌，不如现实中好好生活。 – 《人民日报》<br>5.真正的优秀不是别人逼出来的，而是自己和自己死磕。 – 《人民日报》<br>6.时代的考题已经列出，我们的答卷正在写就。 – 《人民日报》<br>7.人生不就是这样，经历过一次次考验才能成长；人生不就是这样，哪怕雨雪霏霾也要去追寻阳光。 – 《人民日报》<br>8.忆往昔，百年征程砥砺“同心”；看今朝，千秋伟业催人奋进。 – 《人民日报》<br>9.真理的波涛，喷涌而出就奔流不息；理想的火焰，一经点燃就不会熄灭。 – 《人民日报》<br>10.青春的烦恼，只有成长能解决；发展的瓶颈，只有成长才能突破。 – 《人民日报》<br>11.如果你想做一件事，马上就开始，别怕错。一辈子那么长，我们有的是时间来纠正。更何况，只要你开始，就会有收获。 – 《人民日报》</p><p>12.回望历史问初心，千秋伟业谁扛鼎？壮志豪情应犹在，逐梦不止方年轻。 – 陈凌 《人民日报》</p><p>13.距离并不是问题，相向而行才是关键 – 《人民日报》</p><p>14.所有人都在和过去好好告别之后，开始了新的生活，我们带着爱和希望踏上了人生又一段征程。此时回首，对过去满是感激。正是因为那些黯淡混浊的过去，才成就了此刻这个闪闪发光的自己。 – 《人民日报》</p><p>15.坚持一次早起，也许你能多写一篇晨间日记，多看20页书，多记几十个单词。短期看收效不大，但长期如此，往往决定了人生的差距。据说早起的人都有好运气，不妨从今天开始，把时间掌握在自己手里。 – 《人民日报》</p><p>16.生活是活给自己看的，你有多大成色，世界才会给你多大脸色。 – 《人民日报》</p><p>17.真相不是一块橡皮泥，可以随意揉捏；事实不是一张空白纸，可以自由裁剪。 – 《人民日报》</p><p>18.人生这条路很长，未来如星辰大海般璀璨，不必踟躇于过去的半亩方塘。那些所谓的遗憾，可能是一种成长；那些曾受过的伤，终会化作照亮前路的光。 – 《人民日报》</p><p>19.不以爱小而不为。很多时候,爱无关多么轰轰烈烈的表达,却恰恰来自于日常而琐碎的小事中,是发自内心的一举手一投足。赠人玫瑰,手有余香。 – 《人民日报》</p><p>20.时代有时代的大潮流、大节奏，我们也要有自己的小浪潮、小节奏，跟着时代奔跑，别掉了自有节拍。 – 《人民日报》</p>]]></content>
      
      
      <categories>
          
          <category> 考编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode12 占用空间过大的解决方法</title>
      <link href="/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-74.png" alt="upload successful"><br>Xcode12 硬盘占用空间 28G ，装完之后，让本不富裕的硬盘空间雪上加霜。<br>是啥占用了这么多空间？激发了我的好奇心。</p><span id="more"></span><p>三个占用空间最大的文件分别是:</p><p>第一名：iOS.simruntime  9.76 GB<br>第二名：tvOS.simruntime 5.39 GB<br>第三名：watchOS.simruntime 6.83 GB<br>iOS.simruntime日常使用删不得，tvOS.simruntime， watchOS.simruntime ，大部分开发者接触不到，可直接删除</p><p>文件路径：</p><p>Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/watchOS.simruntime</p><p>Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/tvOS.simruntime<br>enjoy~</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吹爆这个最近在用的 IDEA 神器！</title>
      <link href="/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/"/>
      <url>/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-59.png" alt="upload successful"></p><p>在做源码分析的时候，我们常常会有这样一种需求，一堆源码看完后，我想画个时序图把思路捋一下，像下面这样：</p><span id="more"></span><p><img src="/images/pasted-60.png" alt="upload successful"><br>画图的工具有很多，相信大部分小伙伴也都会画。<br>然而，画图太费时间了！！！而且这个图跟我们的代码关联性很大，就是照着代码画的。<br>那么问题就来了，能不能照着代码生成呢？要是能够照着代码生成，岂不是要爽很多。<br>今天松哥就给大家介绍一个我最近在用的 IDEA 插件 SequenceDiagram。</p><p>我不是那种收集狂，虽然我的笔记本并不卡，但是对于 IDEA 中安装插件我还是非常慎重的，很少装。不过这个 SequenceDiagram 确实不错，帮了我大忙，因此这里就给大家安利下。</p><ol><li>安装<br>先来时说说安装，IDEA 插件市场直接搜索并安装，这个是基本技能，我就不多说了：</li></ol><p><img src="/images/pasted-61.png" alt="upload successful"><br>装好之后记得重启一下 IDEA。<br>2. 功能<br>再来说说这个插件都有哪些功能？</p><p>生成简单的时序图。<br>通过单击时序图上的文本来导航代码。<br>可以从时序图中删除某一个类。<br>可以将时序图导出为图像。<br>可以将时序图导出为 PlantUML 文件。</p><p>另外还有三个实验性的功能：</p><p>智能界面<br>Lambda 表达式<br>Kotlin 支持</p><ol start="3"><li>用法<br>安装好 SequenceDiagram 之后，我们可以从如下几个地方启用它：</li></ol><p>在导航工具栏中，出现了如下图标（IDEA 左下角）：</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>工具菜单中 Tools -&gt; Sequence Diagram</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>在编辑器右键菜单中 Sequence Diagram …</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>在 IntentionAction 提示中 Generate sequence diagram（光标放在方法名上，按 alt+enter 或者 option+enter）：</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>通过这些地方我们可以生成时序图，最终生成的时序图如下：</p><p><img src="/images/pasted-66.png" alt="upload successful"><br>由图中可以清楚的看到方法的调用以及返回过程。<br>这张图中有几个细节，我们分别来看下。<br>先看左边一列按钮。<br>第一个三角是重新生成按钮（不好使，似乎有 BUG）。<br>第二个扳手是设置一些生成的细节，例如方法调用的深度，是否忽略 get/set，是否忽略私有方法/构造方法 等，如下图：</p><p><img src="/images/pasted-67.png" alt="upload successful"><br>下面的都是保存按钮了，可以保存为不同格式，小伙伴们可以自行尝试。<br>再看右边的图。<br>鼠标双击类名/方法名，会跳转到对应的类/方法上。<br>鼠标在类名/方法名上右键单击，可以从图中移除一个类/方法。</p><p><img src="/images/pasted-68.png" alt="upload successful"><br>差不多就这些用法吧，比较简单却很管用的一个插件，感兴趣的小伙伴可以试试哦～</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官问我JVM内存结构，我真的是</title>
      <link href="/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/"/>
      <url>/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-8.png" alt="upload successful"><br>面试官：今天来聊聊JVM的内存结构吧？<br>候选者：嗯，好的<br>候选者：前几次面试的时候也提到了：class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」<br>候选者：而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」<br>候选者：简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈<br>候选者：要值得注意的是：这是JVM「规范」的分区概念，到具体的实现落地，不同的厂商实现可能是有所区别的。<br> <span id="more"></span><br><img src="/images/pasted-0.png" alt="upload successful"><br>面试官：嗯，顺便讲下你这图上每个区域的内容吧。<br>候选者：好的，那我就先从「程序计数器」开始讲起吧。<br>候选者：Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」<br>候选者：所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）<br>面试官：好的，理解了。<br>候选者：那接下来我就说下「虚拟机栈」吧<br>候选者：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址</p><p><img src="/images/pasted-1.png" alt="upload successful"><br>候选者：了解了「虚拟机栈」的组成后，也不难猜出它的作用了：它保存方法了局部变量、部分变量的计算并参与了方法的调用和返回。<br>面试官：ok，了解了<br>候选者：下面就说下「本地方法栈」吧<br>候选者：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。<br>面试官：嗯…<br>候选者：嗯，说完了「本地方法栈」、「虚拟机栈」和「程序计数器」，哦，下面还有「方法区」和「堆」<br>候选者：那我先说「方法区」吧<br>候选者：前面提到了运行时数据区这个「分区」是JVM的「规范」，具体的落地实现，不同的虚拟机厂商可能是不一样的<br>候选者：所以「方法区」也只是 JVM 中规范的一部分而已。<br>候选者：在HotSpot虚拟机，就会常常提到「永久代」这个词。HotSpot虚拟机在「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商的虚拟机其实是没有「永久代」的概念的。</p><p><img src="/images/pasted-2.png" alt="upload successful"><br>候选者：我们下面的内容就都用HotSpot虚拟机来说明好了。<br>候选者：在JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了<br>面试官：嗯…<br>候选者：方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<br>候选者：类信息又包括了类的版本、字段、方法、接口和父类等信息。<br>候选者：常量池又可以分「静态常量池」和「运行时常量池」<br>候选者：静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。<br>候选者：「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息。</p><p><img src="/images/pasted-3.png" alt="upload successful"><br>面试官：嗯…<br>候选者：又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的<br>候选者：但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）<br>面试官：嗯，这信息量有点多<br>面试官：我想问下，你说从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？<br>候选者：最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。<br>候选者：按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」，主要是叫法不同，意思到位就好）<br>候选者：而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</p><p><img src="/images/pasted-4.png" alt="upload successful"><br>面试官：嗯，我听懂了<br>面试官：最后来讲讲「堆」这块区域吧<br>候选者：嗯，「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它<br>候选者：「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成<br>候选者：不多BB，我也画图吧</p><p><img src="/images/pasted-6.png" alt="upload successful"><br>候选者：将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）<br>面试官：那垃圾回收这块等下次吧，这个延伸下去又很多东西了<br>面试官：你要不先讲讲JVM内存结构和Java内存模型有啥区别吧？<br>候选者：他们俩没有啥直接关联，其实两次面试过后，应该你就有感觉了<br>候选者：Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果<br>候选者：Java内存结构（又称为运行时数据区域），它描述着当我们的class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担着什么作用。<br>面试官：了解了<br>今日总结：JVM内存结构组成（JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的）</p><p><img src="/images/pasted-7.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
