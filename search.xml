<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>资深开发竟然不清楚int(1)和int(10)的区别</title>
      <link href="/2022/02/08/%E8%B5%84%E6%B7%B1%E5%BC%80%E5%8F%91%E7%AB%9F%E7%84%B6%E4%B8%8D%E6%B8%85%E6%A5%9Aint-1-%E5%92%8Cint-10-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/08/%E8%B5%84%E6%B7%B1%E5%BC%80%E5%8F%91%E7%AB%9F%E7%84%B6%E4%B8%8D%E6%B8%85%E6%A5%9Aint-1-%E5%92%8Cint-10-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-28.png" alt="upload successful"></p><span id="more"></span><h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><hr><p>最近遇到个问题，有个表的要加个user_id字段，user_id字段可能很大，于是我提mysql工单<table><tr><td bgcolor="#FF4500">alter table xxx ADD user_id int(1)。</td></tr></table>领导看到我的sql工单，于是说：这int(1)怕是不够用吧，接下来是一通解释。<br><br>其实这不是我第一次遇到这样的问题了，其中不乏有工作5年以上的老司机。包括我经常在也看到同事也一直使用int(10)，感觉用了int(1)，字段的上限就被限制，真实情况肯定不是这样。<br></p><h3 id="数据说话"><a href="#数据说话" class="headerlink" title="数据说话"></a>数据说话</h3><hr><p>我们知道在mysql中 int占4个字节，那么对于无符号的int，最大值是2^32-1 = 4294967295，将近40亿，难道用了int(1)，就不能达到这个最大值吗？<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(1) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>id字段为无符号的int(1)，我来插入一个最大值看看。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO `user` (`id`) VALUES (4294967295);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到成功了，说明int后面的数字，不影响int本身支持的大小，int(1)、int(2)…int(10)没什么区别。<br></p><h3 id="零填充"><a href="#零填充" class="headerlink" title="零填充"></a>零填充</h3><hr><p>一般int后面的数字，配合zerofill一起使用才有效。先看个例子：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(4) unsigned zerofill NOT NULL AUTO_INCREMENT,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意int(4)后面加了个zerofill，我们先来插入4条数据。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO `user` (`id`) VALUES (1),(10),(100),(1000);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分别插入1、10、100、1000 4条数据，然后我们来查询下：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 0001 |</span><br><span class="line">| 0010 |</span><br><span class="line">| 0100 |</span><br><span class="line">| 1000 |</span><br><span class="line">+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过数据可以发现 int(4) + zerofill实现了不足4位补0的现象，单单int(4)是没有用的。 而且对于0001这种，底层存储的还是1，只是在展示的会补0。<br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>int后面的数字不能表示字段的长度，int(num)一般加上zerofill，才有效果。zerofill的作用一般可以用在一些编号相关的数字中，比如学生的编号 001 002 … 999这种，如果mysql没有零填充的功能，但是你又要格式化输出等长的数字编号时，那么你只能自己处理了。<br><br><img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用 Vsftpd 搭建 FTP 服务</title>
      <link href="/2022/01/27/Linux-%E4%BD%BF%E7%94%A8-Vsftpd-%E6%90%AD%E5%BB%BA-FTP-%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/01/27/Linux-%E4%BD%BF%E7%94%A8-Vsftpd-%E6%90%AD%E5%BB%BA-FTP-%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-25.png" alt="upload successful"><br>&nbsp;&nbsp;本文以 centos 的Linux服务器为例，使用 Vsftpd 搭建被动模式的 FTP 服务。</p><span id="more"></span><h2 id="FTP-的两种模式"><a href="#FTP-的两种模式" class="headerlink" title="FTP 的两种模式"></a>FTP 的两种模式</h2><hr><p>FTP 存在两种模式，PORT(主动)模式和PASV(被动)模式。</p><h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h3><p>FTP服务器“主动”去连接客户端的数据端口来传输数据。 即客户端从一个任意的非特权端口N（N&gt;1024）连接到FTP服务器的21端口。然后客户端开始监听N+1，并发送 PORT N+1 到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。</p><p><img src="/images/pasted-26.png" alt="upload successful"></p><h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h3><p>FTP服务器“被动”等待客户端来连接自己的数据端口。 即当开启一个FTP连接时，客户端打开两个任意的非特权本地端口（N &gt;1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交 PORT 命令并允许服务器来回连它的数据端口，而是提交 PASV 命令。这样做的结果是服务器会开启一个任意的非特权端口（P &gt; 1024），并发送 PORT P 命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。(此模式下的FTP服务器不需要开启tcp 20端口)</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h3 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h3><p>（1）PORT（主动）模式只要开启服务器的21和20端口，而PASV（被动）模式需要开启服务器大于1024所有tcp端口和21端口。<br>（2）从网络安全的角度来看的话似乎 PORT 模式更安全，而 PASV 更不安全，那么为什么 RFC 要在 PORT 基础再制定一个 PASV 模式呢？其实 RFC 制定 PASV 模式的主要目的是为了数据传输安全角度出发的，因为 PORT 使用固定20端口进行传输数据，那么作为黑客很容使用sniffer等探嗅器抓取 ftp 数据，这样一来通过 PORT 模式传输数据很容易被黑客窃取，因此使用 PASV 方式来架设 ftp server 是最安全绝佳方案。</p><h2 id="安装-Vsftpd"><a href="#安装-Vsftpd" class="headerlink" title="安装 Vsftpd"></a>安装 Vsftpd</h2><ol><li>安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>设置开机启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置-Vsftpd"><a href="#配置-Vsftpd" class="headerlink" title="配置 Vsftpd"></a>配置 Vsftpd</h2><ol><li>为 FTP 服务创建一个用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd ftpuser</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>设置该用户的密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd ftpuser</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>为 FTP 服务创建一个用户</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/ftp/ftpupload</span><br><span class="line">chown -R ftpuser:ftpuser /var/ftp/ftpupload</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>编辑配置文件 /etc/vsftpd/vsftpd.conf</li></ol><ul><li>修改 配置文件之前先备份 </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/vsftpd.conf /etc/vsftpd.conf.back</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改以下配置参数,监听 IPv4 或 IPv6 只能选择开启一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> \# 匿名用户的登录权限</span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line">\# 本地用户的登录权限</span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line">\# 将所有用户限制在主目录</span><br><span class="line">chroot_local_user=</span><br><span class="line"></span><br><span class="line">\# 启动限制用户的名单</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"></span><br><span class="line">\# 例外用户列表文件的路径</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">\# 开启监听 IPv4 sockets</span><br><span class="line">listen=YES</span><br><span class="line"></span><br><span class="line">\# 关闭监听 IPv6</span><br><span class="line">\#listen_ipv6=YES</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建并编辑配置中 chroot_list_file 指定的例外用户列表文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/vsftpd/chroot_list</span><br></pre></td></tr></table></figure><ul><li>重启 FTP 服务</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中为什么不建议v-if 和v-for一起使用？</title>
      <link href="/2022/01/27/vue%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEv-if-%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F/"/>
      <url>/2022/01/27/vue%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEv-if-%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-24.png" alt="upload successful"></p><span id="more"></span><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染<br></p><p>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名<br></p><p>在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化<br></p><p>两者在用法上<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo v-if=&quot;isShow&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &#123;&#123; item.label &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、优先级"><a href="#二、优先级" class="headerlink" title="二、优先级"></a>二、优先级</h2><p>v-if与v-for都是vue模板系统中的指令<br></p><p>在vue模板编译的时候，会将指令系统转化成可执行的render函数<br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写一个p标签，同时使用v-if与 v-for <br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in list&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建vue实例，存放isShow与items数据<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &quot;#app&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123; name: &quot;Tom&quot; &#125;,</span><br><span class="line">        &#123; name: &quot;Jack&quot; &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isShow() &#123;</span><br><span class="line">      return this.list &amp;&amp; this.list.length &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板指令的代码都会生成在render函数中，通过app.$options.render可以得到渲染函数<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with (this) &#123; return </span><br><span class="line">    _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, </span><br><span class="line">    _l((list), function (item) </span><br><span class="line">    &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\n&quot; + _s(item.name) + &quot;\n&quot;)]) : _e() &#125;), 0) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>_l是vue的列表渲染函数，函数内部都会进行一次if判断<br></p><p>初步得到结论：v-for优先级是比v-if高<br></p><p>再将v-for与v-if置于不同标签<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with(this)&#123;return </span><br><span class="line">    _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,</span><br><span class="line">    [(isShow)?[_v(&quot;\n&quot;),</span><br><span class="line">    _l((list),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.name))])&#125;)]:_e()],2)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染<br></p><p>我们再在查看下vue源码<br></p><p>源码位置：/vue-dev/src/compiler/codegen/index.js<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function genElement (el: ASTElement, state: CodegenState): string &#123;</span><br><span class="line">  if (el.parent) &#123;</span><br><span class="line">    el.pre = el.pre || el.parent.pre</span><br><span class="line">  &#125;</span><br><span class="line">  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    return genStatic(el, state)</span><br><span class="line">  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    return genOnce(el, state)</span><br><span class="line">  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    return genFor(el, state)</span><br><span class="line">  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    return genIf(el, state)</span><br><span class="line">  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">    return genChildren(el, state) || &#x27;void 0&#x27;</span><br><span class="line">  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;</span><br><span class="line">    return genSlot(el, state)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在进行if判断的时候，v-for是比v-if先进行判断<br></p><p>最终结论：v-for优先级比v-if高<br></p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ol><li>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li><li>如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;isShow&quot;&gt;</span><br><span class="line">    &lt;p v-for=&quot;item in list&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    items: function() &#123;</span><br><span class="line">      return this.list.filter(function (item) &#123;</span><br><span class="line">        return item.isShow</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地在 Spring Boot 中使用自定义注解，AOP 切面统一打印出入参日志</title>
      <link href="/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-Spring-Boot-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8CAOP-%E5%88%87%E9%9D%A2%E7%BB%9F%E4%B8%80%E6%89%93%E5%8D%B0%E5%87%BA%E5%85%A5%E5%8F%82%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/26/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8-Spring-Boot-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8CAOP-%E5%88%87%E9%9D%A2%E7%BB%9F%E4%B8%80%E6%89%93%E5%8D%B0%E5%87%BA%E5%85%A5%E5%8F%82%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-11.png" alt="upload successful"></p><span id="more"></span><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><hr><p>一、先看看切面日志输出效果</p><p>二、添加 AOP Maven 依赖</p><p>三、自定义日志注解</p><p>四、配置 AOP 切面</p><p>五、怎么使用呢？</p><p>六、对于文件上传好使不？</p><p>七、只想在开发环境和测试环境中使用？</p><p>八、多切面如何指定优先级？</p><hr><h5 id="一、先看看切面日志输出效果"><a href="#一、先看看切面日志输出效果" class="headerlink" title="一、先看看切面日志输出效果"></a>一、先看看切面日志输出效果</h5><hr><p>在看看实现方法之前，我们先看下切面日志输出效果咋样：<br></p><p><img src="/images/pasted-12.png" alt="upload successful"><br>Spring boot 自定义注解，aop切面统一打印请求日志效果图<br><br>从上图中可以看到，每个对于每个请求，开始与结束一目了然，并且打印了以下参数：</p><ul><li>URL: 请求接口地址；</li><li>Description: 接口的中文说明信息；</li><li>HTTP Method: 请求的方法，是 POST, GET, 还是 DELETE 等；</li><li>Class Method: 被请求的方法路径 : 包名 + 方法名;</li><li>IP: 请求方的 IP 地址；</li><li>Request Args: 请求入参，以 JSON 格式输出；</li><li>Response Args: 响应出参，以 JSON 格式输出；</li><li>Time-Consuming: 请求耗时，以此估算每个接口的性能指数；</li></ul><h5 id="二、添加-AOP-Maven-依赖"><a href="#二、添加-AOP-Maven-依赖" class="headerlink" title="二、添加 AOP Maven 依赖"></a>二、添加 AOP Maven 依赖</h5><hr><p>在项目 pom.xml 文件中添加依赖：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- aop 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用于日志切面中，以 json 格式打印出入参 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="三、自定义日志注解"><a href="#三、自定义日志注解" class="headerlink" title="三、自定义日志注解"></a>三、自定义日志注解</h5><hr><p>让我们来自定义一个日志注解，如下所示：<br><img src="/images/pasted-13.png" alt="upload successful"></p><ol><li>什么时候使用该注解，我们定义为运行时；</li><li>注解用于什么地方，我们定义为作用于方法上；</li><li>注解是否将包含在 JavaDoc 中；</li><li>注解名为 WebLog;</li><li>定义一个属性，默认为空字符串；</li></ol><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.exception.springbootaopwebrequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 犬小哈 （微信号：小哈学Java）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span> www.exception.site</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 下午9:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@discription</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志描述信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，一个完整的自定义注解就定义完成了。</p><h5 id="四、配置-AOP-切面"><a href="#四、配置-AOP-切面" class="headerlink" title="四、配置 AOP 切面"></a>四、配置 AOP 切面</h5><hr><p>在配置 AOP 切面之前，我们需要了解下 aspectj 相关注解的作用：</p><ul><li>@Aspect：声明该类为一个注解类；</li><li>@Pointcut：定义一个切点，后面跟随一个表达式，表达式可以定义为切某个注解，也可以切某个 package 下的方法；<br>切点定义好后，就是围绕这个切点做文章了：</li><li>@Before: 在切点之前，织入相关代码；</li><li>@After: 在切点之后，织入相关代码;</li><li>@AfterReturning: 在切点返回内容后，织入相关代码，一般用于对返回值做些加工处理的场景；</li><li>@AfterThrowing: 用来处理当织入的代码抛出异常后的逻辑处理;</li><li>@Around: 环绕，可以在切入点前后织入代码，并且可以自由的控制何时执行切点；</li></ul><p><img src="/images/pasted-14.png" alt="upload successful"><br>&nbsp;&nbsp; 注解执行顺序<br></p><p>接下来，定义一个 WebLogAspect.java 切面类，声明一个切点：<br><img src="/images/pasted-15.png" alt="upload successful"><br>&nbsp;&nbsp; 定义一个切点<br></p><p>然后，定义 @Around 环绕，用于何时执行切点：<br><img src="/images/pasted-16.png" alt="upload successful"><br>&nbsp;&nbsp; 环绕<br></p><ol><li>记录一下调用接口的开始时间；</li><li>执行切点，执行切点后，会去依次调用 @Before -&gt; 接口逻辑代码 -&gt; @After -&gt; @AfterReturning；</li><li>打印出参；</li><li>打印接口处理耗时；</li><li>返回接口返参结果；</li></ol><p>再来看看 @Before 方法：</p><p><img src="/images/pasted-17.png" alt="upload successful"><br>&nbsp;&nbsp;@Before<br><br>看注释功能说明，因为注释说得还是比较清楚的！</p><p>最后，用 @After 来做个收尾：</p><p><img src="/images/pasted-18.png" alt="upload successful"><br>&nbsp;&nbsp;换行</p><p><img src="/images/pasted-19.png" alt="upload successful"><br>&nbsp;&nbsp;@After</p><p>我们在每个接口的最后，打印日志结束标志。最后再看下项目包结构：</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>&nbsp;&nbsp;项目包结构</p><p>到这里，切面相关的代码就完成了！</p><p>上完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.exception.springbootaopwebrequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 犬小哈 （微信号：小哈学Java）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span> www.exception.site</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 下午9:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@discription</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger         = LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line">    <span class="comment">/** 换行符 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.lineSeparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 以自定义 <span class="doctag">@WebLog</span> 注解为切点 */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(site.exception.springbootaopwebrequest.aspect.WebLog)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之前织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 开始打印请求日志</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 @WebLog 注解的描述信息</span></span><br><span class="line">        String methodDescription = getAspectLogDescription(joinPoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印请求相关参数</span></span><br><span class="line">        logger.info(<span class="string">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 url</span></span><br><span class="line">        logger.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">// 打印描述信息</span></span><br><span class="line">        logger.info(<span class="string">&quot;Description    : &#123;&#125;&quot;</span>, methodDescription);</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        logger.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        logger.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        logger.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>, <span class="keyword">new</span> Gson().toJson(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之后织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 接口结束后换行，方便分割查看</span></span><br><span class="line">        logger.info(<span class="string">&quot;=========================================== End ===========================================&quot;</span> + LINE_SEPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 打印出参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class="keyword">new</span> Gson().toJson(result));</span><br><span class="line">        <span class="comment">// 执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切面注解的描述</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 描述信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAspectLogDescription</span><span class="params">(JoinPoint joinPoint)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String targetName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] arguments = joinPoint.getArgs();</span><br><span class="line">        Class targetClass = Class.forName(targetName);</span><br><span class="line">        Method[] methods = targetClass.getMethods();</span><br><span class="line">        StringBuilder description = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                Class[] clazzs = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (clazzs.length == arguments.length) &#123;</span><br><span class="line">                    description.append(method.getAnnotation(WebLog.class).description());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> description.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="五、怎么使用呢？"><a href="#五、怎么使用呢？" class="headerlink" title="五、怎么使用呢？"></a>五、怎么使用呢？</h5><hr><p>因为我们的切点是自定义注解 @WebLog, 所以我们仅仅需要在 Controller 控制器的每个接口方法添加 @WebLog 注解即可，如果我们不想某个接口打印出入参日志，不加注解就可以了：</p><p><img src="/images/pasted-21.png" alt="upload successful"><br>&nbsp;&nbsp;用户登录接口</p><h5 id="六、对于文件上传好使不？"><a href="#六、对于文件上传好使不？" class="headerlink" title="六、对于文件上传好使不？"></a>六、对于文件上传好使不？</h5><hr><p>是好使的！不论是单文件上传，抑或是多文件上传，切面日志均运行良好，这里测试的东西，小哈就不贴出来了。有兴趣的小伙伴可以试试！</p><h5 id="七、只想在开发环境和测试环境中使用？"><a href="#七、只想在开发环境和测试环境中使用？" class="headerlink" title="七、只想在开发环境和测试环境中使用？"></a>七、只想在开发环境和测试环境中使用？</h5><hr><p>对于那些性能要求较高的应用，不想在生产环境中打印日志，只想在开发环境或者测试环境中使用，要怎么做呢？我们只需为切面添加 @Profile 就可以了，如下图所示：</p><p><img src="/images/pasted-22.png" alt="upload successful"><br>&nbsp;&nbsp;指定profile</p><p>这样就指定了只能作用于 dev 开发环境和 test 测试环境，生产环境 prod 是不生效的！</p><h5 id="八、多切面如何指定优先级？"><a href="#八、多切面如何指定优先级？" class="headerlink" title="八、多切面如何指定优先级？"></a>八、多切面如何指定优先级？</h5><hr><p>假设说我们的服务中不止定义了一个切面，比如说我们针对 Web 层的接口，不止要打印日志，还要校验 token 等。要如何指定切面的优先级呢？也就是如何指定切面的执行顺序？<br>我们可以通过 @Order(i)注解来指定优先级，注意：i 值越小，优先级则越高。<br>假设说我们定义上面这个日志切面的优先级为 @Order(10), 然后我们还有个校验 token 的切面 CheckTokenAspect.java，我们定义为了 @Order(11), 那么它们之间的执行顺序如下：</p><p><img src="/images/pasted-23.png" alt="upload successful"><br>&nbsp;&nbsp;多切点优先级</p><p>我们可以总结一下：</p><ul><li>在切点之前，@Order 从小到大被执行，也就是说越小的优先级越高；</li><li>在切点之后，@Order 从大到小被执行，也就是说越大的优先级越高；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 常用语法</title>
      <link href="/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/25/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-10.png" alt="upload successful"></p><p>Markdown 的语法全由一些符号所组成，易读易写。本文主要分享我平时经常使用到的 Markdown 语法。</p><span id="more"></span><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="单引用"><a href="#单引用" class="headerlink" title="单引用"></a>单引用</h3><p>使用符号 &gt; 标记区块引用，如：<br><br><br>&gt;我的博客：Yuanqian’s Blog，不止于技术分享。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog，不止于技术分享。</p></blockquote><h3 id="引用内的引用"><a href="#引用内的引用" class="headerlink" title="引用内的引用"></a>引用内的引用</h3><p>&gt; 标记里再使用 &gt;&gt; 标记，如：<br>&gt; 我的博客：Yuanqian’s Blog<br>&gt;&gt; 不止于技术分享，每天进步一点点，欢迎大家访问。<br>效果如下：</p><blockquote><p>我的博客：Yuanqian’s Blog</p><blockquote><p>不止于技术分享，每天进步一点点，欢迎大家访问。</p></blockquote></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>1、用底线的形式，= （第一阶标题）和 - （第二阶标题），数量不限，如：</p><p>效果是截图，左边是语法，右边是效果，下同。<br><img src="/images/pasted-7.png" alt="upload successful"></p><p>2、行首插入 1 到 6 个 #，对应到标题 1 到 6 阶，如：<br><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[Yuanqian’s Blog](<a href="https://zhangyuanqian.top/">https://zhangyuanqian.top/</a>)<br>效果如下：<br><br><a href="https://zhangyuanqian.top/">Yuanqian’s Blog</a></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Java 代表代码语言，效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintCanvas</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        canvas.drawCircle(<span class="number">500</span>, <span class="number">550</span>, <span class="number">500</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>用两个星号或下划线包含内容，直接展示效果如下：<br><br><br>** 我的博客：Yuanqian’s Blog **</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。<br></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用*、+、—作为列表标记，如：</p><p>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br><br>* 我的博客：Yuanqian’s Blog<br></p><p>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br><br>+ 我的博客：Yuanqian’s Blog<br></p><p>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br><br>- 我的博客：Yuanqian’s Blog<br></p><p>三种写法都是如下效果:<br></p><ul><li>我的博客：Yuanqian’s Blog<br></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>只要数字接着一个英文句点，如：<br></p><p>1.bird<br><br>2.tiger<br><br>3.monkey<br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Markdown 常用语法介绍完毕，欢迎补充。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人民日报金句摘抄</title>
      <link href="/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/"/>
      <url>/2021/12/06/%E4%BA%BA%E6%B0%91%E6%97%A5%E6%8A%A5%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-76.png" alt="upload successful"></p><p>1.峥嵘过去已经彪炳史册，璀璨当下正在不断延伸，光明未来需要踏实开拓。 – 《人民日报》<br>2.最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。 – 《人民日报》</p><span id="more"></span><p>3.岁月因青春慨然以赴而更加静好，世间因少年挺身向前而更加瑰丽。 – 《人民日报》<br>4.与其朋友圈字斟句酌，不如现实中好好生活。 – 《人民日报》<br>5.真正的优秀不是别人逼出来的，而是自己和自己死磕。 – 《人民日报》<br>6.时代的考题已经列出，我们的答卷正在写就。 – 《人民日报》<br>7.人生不就是这样，经历过一次次考验才能成长；人生不就是这样，哪怕雨雪霏霾也要去追寻阳光。 – 《人民日报》<br>8.忆往昔，百年征程砥砺“同心”；看今朝，千秋伟业催人奋进。 – 《人民日报》<br>9.真理的波涛，喷涌而出就奔流不息；理想的火焰，一经点燃就不会熄灭。 – 《人民日报》<br>10.青春的烦恼，只有成长能解决；发展的瓶颈，只有成长才能突破。 – 《人民日报》<br>11.如果你想做一件事，马上就开始，别怕错。一辈子那么长，我们有的是时间来纠正。更何况，只要你开始，就会有收获。 – 《人民日报》</p><p>12.回望历史问初心，千秋伟业谁扛鼎？壮志豪情应犹在，逐梦不止方年轻。 – 陈凌 《人民日报》</p><p>13.距离并不是问题，相向而行才是关键 – 《人民日报》</p><p>14.所有人都在和过去好好告别之后，开始了新的生活，我们带着爱和希望踏上了人生又一段征程。此时回首，对过去满是感激。正是因为那些黯淡混浊的过去，才成就了此刻这个闪闪发光的自己。 – 《人民日报》</p><p>15.坚持一次早起，也许你能多写一篇晨间日记，多看20页书，多记几十个单词。短期看收效不大，但长期如此，往往决定了人生的差距。据说早起的人都有好运气，不妨从今天开始，把时间掌握在自己手里。 – 《人民日报》</p><p>16.生活是活给自己看的，你有多大成色，世界才会给你多大脸色。 – 《人民日报》</p><p>17.真相不是一块橡皮泥，可以随意揉捏；事实不是一张空白纸，可以自由裁剪。 – 《人民日报》</p><p>18.人生这条路很长，未来如星辰大海般璀璨，不必踟躇于过去的半亩方塘。那些所谓的遗憾，可能是一种成长；那些曾受过的伤，终会化作照亮前路的光。 – 《人民日报》</p><p>19.不以爱小而不为。很多时候,爱无关多么轰轰烈烈的表达,却恰恰来自于日常而琐碎的小事中,是发自内心的一举手一投足。赠人玫瑰,手有余香。 – 《人民日报》</p><p>20.时代有时代的大潮流、大节奏，我们也要有自己的小浪潮、小节奏，跟着时代奔跑，别掉了自有节拍。 – 《人民日报》</p>]]></content>
      
      
      <categories>
          
          <category> 考编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode12 占用空间过大的解决方法</title>
      <link href="/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/06/Xcode12-%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-74.png" alt="upload successful"><br>Xcode12 硬盘占用空间 28G ，装完之后，让本不富裕的硬盘空间雪上加霜。<br>是啥占用了这么多空间？激发了我的好奇心。</p><span id="more"></span><p>三个占用空间最大的文件分别是:</p><p>第一名：iOS.simruntime  9.76 GB<br>第二名：tvOS.simruntime 5.39 GB<br>第三名：watchOS.simruntime 6.83 GB<br>iOS.simruntime日常使用删不得，tvOS.simruntime， watchOS.simruntime ，大部分开发者接触不到，可直接删除</p><p>文件路径：</p><p>Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/watchOS.simruntime</p><p>Xcode.app/Contents/Developer/Platforms/AppleTVOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/tvOS.simruntime<br>enjoy~</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吹爆这个最近在用的 IDEA 神器！</title>
      <link href="/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/"/>
      <url>/2021/11/09/%E5%90%B9%E7%88%86%E8%BF%99%E4%B8%AA%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E7%9A%84-IDEA-%E7%A5%9E%E5%99%A8%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-59.png" alt="upload successful"></p><p>在做源码分析的时候，我们常常会有这样一种需求，一堆源码看完后，我想画个时序图把思路捋一下，像下面这样：</p><span id="more"></span><p><img src="/images/pasted-60.png" alt="upload successful"><br>画图的工具有很多，相信大部分小伙伴也都会画。<br>然而，画图太费时间了！！！而且这个图跟我们的代码关联性很大，就是照着代码画的。<br>那么问题就来了，能不能照着代码生成呢？要是能够照着代码生成，岂不是要爽很多。<br>今天松哥就给大家介绍一个我最近在用的 IDEA 插件 SequenceDiagram。</p><p>我不是那种收集狂，虽然我的笔记本并不卡，但是对于 IDEA 中安装插件我还是非常慎重的，很少装。不过这个 SequenceDiagram 确实不错，帮了我大忙，因此这里就给大家安利下。</p><ol><li>安装<br>先来时说说安装，IDEA 插件市场直接搜索并安装，这个是基本技能，我就不多说了：</li></ol><p><img src="/images/pasted-61.png" alt="upload successful"><br>装好之后记得重启一下 IDEA。<br>2. 功能<br>再来说说这个插件都有哪些功能？</p><p>生成简单的时序图。<br>通过单击时序图上的文本来导航代码。<br>可以从时序图中删除某一个类。<br>可以将时序图导出为图像。<br>可以将时序图导出为 PlantUML 文件。</p><p>另外还有三个实验性的功能：</p><p>智能界面<br>Lambda 表达式<br>Kotlin 支持</p><ol start="3"><li>用法<br>安装好 SequenceDiagram 之后，我们可以从如下几个地方启用它：</li></ol><p>在导航工具栏中，出现了如下图标（IDEA 左下角）：</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>工具菜单中 Tools -&gt; Sequence Diagram</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>在编辑器右键菜单中 Sequence Diagram …</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>在 IntentionAction 提示中 Generate sequence diagram（光标放在方法名上，按 alt+enter 或者 option+enter）：</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>通过这些地方我们可以生成时序图，最终生成的时序图如下：</p><p><img src="/images/pasted-66.png" alt="upload successful"><br>由图中可以清楚的看到方法的调用以及返回过程。<br>这张图中有几个细节，我们分别来看下。<br>先看左边一列按钮。<br>第一个三角是重新生成按钮（不好使，似乎有 BUG）。<br>第二个扳手是设置一些生成的细节，例如方法调用的深度，是否忽略 get/set，是否忽略私有方法/构造方法 等，如下图：</p><p><img src="/images/pasted-67.png" alt="upload successful"><br>下面的都是保存按钮了，可以保存为不同格式，小伙伴们可以自行尝试。<br>再看右边的图。<br>鼠标双击类名/方法名，会跳转到对应的类/方法上。<br>鼠标在类名/方法名上右键单击，可以从图中移除一个类/方法。</p><p><img src="/images/pasted-68.png" alt="upload successful"><br>差不多就这些用法吧，比较简单却很管用的一个插件，感兴趣的小伙伴可以试试哦～</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官问我JVM内存结构，我真的是</title>
      <link href="/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/"/>
      <url>/2021/11/08/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E6%98%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-8.png" alt="upload successful"><br>面试官：今天来聊聊JVM的内存结构吧？<br>候选者：嗯，好的<br>候选者：前几次面试的时候也提到了：class文件会被类加载器装载至JVM中，并且JVM会负责程序「运行时」的「内存管理」<br>候选者：而JVM的内存结构，往往指的就是JVM定义的「运行时数据区域」<br>候选者：简单来说就分为了5大块：方法区、堆、程序计数器、虚拟机栈、本地方法栈<br>候选者：要值得注意的是：这是JVM「规范」的分区概念，到具体的实现落地，不同的厂商实现可能是有所区别的。<br> <span id="more"></span><br><img src="/images/pasted-0.png" alt="upload successful"><br>面试官：嗯，顺便讲下你这图上每个区域的内容吧。<br>候选者：好的，那我就先从「程序计数器」开始讲起吧。<br>候选者：Java是多线程的语言，我们知道假设线程数大于CPU数，就很有可能有「线程切换」现象，切换意味着「中断」和「恢复」，那自然就需要有一块区域来保存「当前线程的执行信息」<br>候选者：所以，程序计数器就是用于记录各个线程执行的字节码的地址（分支、循环、跳转、异常、线程恢复等都依赖于计数器）<br>面试官：好的，理解了。<br>候选者：那接下来我就说下「虚拟机栈」吧<br>候选者：每个线程在创建的时候都会创建一个「虚拟机栈」，每次方法调用都会创建一个「栈帧」。每个「栈帧」会包含几块内容：局部变量表、操作数栈、动态连接和返回地址</p><p><img src="/images/pasted-1.png" alt="upload successful"><br>候选者：了解了「虚拟机栈」的组成后，也不难猜出它的作用了：它保存方法了局部变量、部分变量的计算并参与了方法的调用和返回。<br>面试官：ok，了解了<br>候选者：下面就说下「本地方法栈」吧<br>候选者：本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。这里的「本地方法」指的是「非Java方法」，一般本地方法是使用C语言实现的。<br>面试官：嗯…<br>候选者：嗯，说完了「本地方法栈」、「虚拟机栈」和「程序计数器」，哦，下面还有「方法区」和「堆」<br>候选者：那我先说「方法区」吧<br>候选者：前面提到了运行时数据区这个「分区」是JVM的「规范」，具体的落地实现，不同的虚拟机厂商可能是不一样的<br>候选者：所以「方法区」也只是 JVM 中规范的一部分而已。<br>候选者：在HotSpot虚拟机，就会常常提到「永久代」这个词。HotSpot虚拟机在「JDK8前」用「永久代」实现了「方法区」，而很多其他厂商的虚拟机其实是没有「永久代」的概念的。</p><p><img src="/images/pasted-2.png" alt="upload successful"><br>候选者：我们下面的内容就都用HotSpot虚拟机来说明好了。<br>候选者：在JDK8中，已经用「元空间」来替代了「永久代」作为「方法区」的实现了<br>面试官：嗯…<br>候选者：方法区主要是用来存放已被虚拟机加载的「类相关信息」：包括类信息、常量池<br>候选者：类信息又包括了类的版本、字段、方法、接口和父类等信息。<br>候选者：常量池又可以分「静态常量池」和「运行时常量池」<br>候选者：静态常量池主要存储的是「字面量」以及「符号引用」等信息，静态常量池也包括了我们说的「字符串常量池」。<br>候选者：「运行时常量池」存储的是「类加载」时生成的「直接引用」等信息。</p><p><img src="/images/pasted-3.png" alt="upload successful"><br>面试官：嗯…<br>候选者：又值得注意的是：从「逻辑分区」的角度而言「常量池」是属于「方法区」的<br>候选者：但自从在「JDK7」以后，就已经把「运行时常量池」和「静态常量池」转移到了「堆」内存中进行存储（对于「物理分区」来说「运行时常量池」和「静态常量池』就属于堆）<br>面试官：嗯，这信息量有点多<br>面试官：我想问下，你说从「JDK8」已经把「方法区」的实现从「永久代」变成「元空间」，有什么区别？<br>候选者：最主要的区别就是：「元空间」存储不在虚拟机中，而是使用本地内存，JVM 不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。<br>候选者：按JDK8版本，总结起来其实就相当于：「类信息」是存储在「元空间」的（也有人把「类信息」这块叫做「类信息常量池」，主要是叫法不同，意思到位就好）<br>候选者：而「常量池」用JDK7开始，从「物理存储」角度上就在「堆中」，这是没有变化的。</p><p><img src="/images/pasted-4.png" alt="upload successful"><br>面试官：嗯，我听懂了<br>面试官：最后来讲讲「堆」这块区域吧<br>候选者：嗯，「堆」是线程共享的区域，几乎类的实例和数组分配的内存都来自于它<br>候选者：「堆」被划分为「新生代」和「老年代」，「新生代」又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成<br>候选者：不多BB，我也画图吧</p><p><img src="/images/pasted-6.png" alt="upload successful"><br>候选者：将「堆内存」分开了几块区域，主要跟「内存回收」有关（垃圾回收机制）<br>面试官：那垃圾回收这块等下次吧，这个延伸下去又很多东西了<br>面试官：你要不先讲讲JVM内存结构和Java内存模型有啥区别吧？<br>候选者：他们俩没有啥直接关联，其实两次面试过后，应该你就有感觉了<br>候选者：Java内存模型是跟「并发」相关的，它是为了屏蔽底层细节而提出的规范，希望在上层(Java层面上)在操作内存时在不同的平台上也有相同的效果<br>候选者：Java内存结构（又称为运行时数据区域），它描述着当我们的class文件加载至虚拟机后，各个分区的「逻辑结构」是如何的，每个分区承担着什么作用。<br>面试官：了解了<br>今日总结：JVM内存结构组成（JVM内存结构又称为「运行时数据区域」。主要有五部分组成：虚拟机栈、本地方法栈、程序计数器、方法区和堆。其中方法区和堆是线程共享的。虚拟机栈、本地方法栈以及程序计数器是线程隔离的）</p><p><img src="/images/pasted-7.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
